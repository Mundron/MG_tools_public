<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>trigger_dummy</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>xxx</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>catch_portal_room_ids</name>
			<script>if PathEditor.portal_to_visit &lt; 41 then
  local node = PathData.node[f("p{PathEditor.portal_to_visit}")]
  local room_id = gmcp.MG.room.info.id
  if len(room_id) &gt; 0 and not table.contains(node.ids, room_id) then
    table.insert(node.ids, room_id)
  end
  PathEditor.portal_to_visit = PathEditor.portal_to_visit + 1
  send(f("teleportiere {PathEditor.portal_to_visit}"))
else
  disableTimer("catch_portal_room_ids")
  PathData:save()
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Wege erstellen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Wegaufzeichnung steuern</name>
				<script>if matches[2] == "start" then
  PathCreator:start()
elseif matches[2] == "stop" then
  PathCreator:stop()
elseif matches[2] == "weiter" then
  PathCreator:continue()
else
  PathCreator:set_goal()
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#wa (start|stop|weiter|ziel)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Knoten definieren</name>
				<script>PathCreator:add_node(matches[2])
if #matches == 5 then
  PathCreator:add_node_title(matches[5])
end </script>
				<command></command>
				<packageName></packageName>
				<regex>^#addnode (\w+)(:(.+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Randknoten hinzufuegen</name>
				<script>PathCreator:add_boundaries(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#addboundaries (\w+) (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Wait erstellen</name>
				<script>local m = matches[1]
if PathCreator:move_forth(m, true) then
  iprint(f("Eine Wartezeit fuer {m:match('%d+')} wurde registriert."), "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#wait \d+$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Blocker erstellen</name>
				<script>local m = matches[1]
local m_parts = string.split(m, ":")
if PathCreator:move_forth(m, true) then
  iprint(f("Blocker-NPC {m_parts[1]:sub(10)}\nmit Knuddeltext\n'{m_parts[2]}'\nund Todesmeldung\n'{m_parts[3]}'\nregistriert."), "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#blocker \w+:.+:.+$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Trigger erstellen</name>
				<script>local m = matches[1]
if PathCreator:move_forth(m, true) then
  iprint(f("Der Trigger mit dem Namen {m:sub(10)} ist registriert."), "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#trigger \w+$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Befehl hinzufügen</name>
				<script>-- gibt das Argument als Gehbewegung aus, welches dann auch
-- in der Wegaufzeichnung gespeichert wird. Zum Beispiel
-- #vor zwaenge durch gebuesch

PathCreator:move_forth(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#vor (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Wegaufzeichnung zeigen</name>
				<script>PathCreator:show_last(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#showrecord(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Einträge löschen</name>
				<script>PathCreator:delete_last(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deleterecord(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Verbindung speichern</name>
				<script>PathCreator:save_new_path(matches[2], matches[3], true)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#sweg (\w+) (\w+)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Einbahn speichern</name>
				<script>PathCreator:save_new_path(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#seinbahn (\w+) (\w+)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Wege editieren</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Zeige/Finde Knoten</name>
				<script>PathEditor:show_node(matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#shownode(\s(\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Zeige/Finde Knoten</name>
				<script>PathEditor:search_node(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#searchnode (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Titel updaten</name>
				<script>PathCreator:add_node_title(matches[2], matches[3], true)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#addtitle (\w+):(.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Titel löschen</name>
				<script>PathEditor:delete_title(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deletetitle (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ID hinzufügen</name>
				<script>PathCreator:add_node(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#addid (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ID loeschen</name>
				<script>PathEditor:delete_id_from_node(matches[2], matches[4])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deleteid (\w+)(\s(\d+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Zeige Weg</name>
				<script>PathEditor:show_path(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#showpath (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Berechne Weg</name>
				<script>PathEditor:show_prepared_path(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#computepath (\w+) (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Lösche Weg</name>
				<script>PathEditor:delete_path(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#deletepath (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Portale sehen</name>
				<script>PathEditor:show_portals()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#showportals$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Portal aendern</name>
				<script>PathEditor:flip_portal(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#flipportal (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Portale erfassen</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex>^#catchportals$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Wege benutzen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="no" isFolder="no">
				<name>Laufe nach X</name>
				<script>PathFinder:go(nil, matches[2], false)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#go (\w+)$</regex>
			</Alias>
			<Alias isActive="no" isFolder="no">
				<name>Renne blind</name>
				<script>if table.size(matches) == 2 then
  PathFinder:go(matches[2], true)
elseif table.size(matches) == 4 then
  PathFinder:walk(matches[2], matches[4])
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#run (\w+)(\s(\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Fortsetzen</name>
				<script>PathFinder:walk_stored_path()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#rerun$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Vorbereiten</name>
				<script>PathEditor:prepare_path(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#prepare (\w+) (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Erneut vorbereiten</name>
				<script>PathEditor:reprepare_path(matches[3], matches[4])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#reprepare(\s(\w+)\s(\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Zuletzt gelaufen</name>
				<script>PathFinder:show_last_runned_path()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#runned$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Richtungserkennung für Wegaufzeichnung</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Zeige Richtungen</name>
				<script>PathEditor:show_aliases()</script>
				<command></command>
				<packageName></packageName>
				<regex>^#showaliases$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Fuege Richtung hinzu</name>
				<script>PathEditor:add_alias(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#addalias (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Lösche Richtung</name>
				<script>PathEditor:delete_alias(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#delalias (\d+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Spezielle Wege</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Parallelwelten</name>
				<script>local para = matches[2]

if not PathFinder.para_start_node then
  PathFinder.para_start_node = PathData.node_by_id[gmcp.MG.room.info.id]
  if not PathFinder.para_start_node then
    eprint("Der Raum ist kein Knotenpunkt.", "WS")
    return
  end
end

local function return_to_start()
  iprint("Gehe wieder zurueck.")
  send("sw", false)
  -- use directly the function otherwise the 
  -- move to southwest isn't fast enough an
  -- expandAlias(f("#go {PathFinder.para_start_node}")
  -- will recognize the portal room as a starting
  -- point.
  PathFinder:go("p32", PathFinder.para_start_node)
  PathFinder.para_start_node = nil
  if PLAYER then
    PLAYER.para = tonumber(para)
    PLAYER:save_setting()
  end
  if MainGUI then
    MainGUI:set_world_background()
    MainGUI:save_setting()
  end
end

if PathFinder.para_start_node then
  -- use manually go function to use extra arguments
  PathFinder:go(PathFinder.para_start_node, "p32", false, false, true) 
  send("no", false)
  send("betrete portal", false)
  send(para, false)
  iprint(f("Portal {para} betreten, kurz warten!"), "WS") 
  -- here comes the tricky part:
  -- we HAVE TO wait for 1.5 seconds
  -- otherwise we will be teleported 
  -- somewhere
  tempTimer(1.5, return_to_start)
else
  eprint("Du befindest dich an keinem Knotenpunkt.", "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#para (\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Sachen verkaufen</name>
				<script>-- save the node names of nodes in shops accessable in all worlds:
PathData.all_world_shops = PathData.all_world_shops or {"brad", "umshop"}
local all_world_shop_count = table.size(PathData.all_world_shops)
-- save the node names of nodes in shops accessable only in normal world:
PathData.normal_world_shops = PathData.normal_world_shops or {}
local normal_world_shop_count = table.size(PathData.normal_world_shops)
-- set an index if not defined yet
PathData.shop_index = PathData.shop_index or 0
iprint(f("Shopindex ist {PathData.shop_index}."), "WS")
--
local shop_index = PathData.shop_index
local chosen_shop
--
if not PLAYER or PLAYER.para == 0 then
  if PathData.shop_index &lt; normal_world_shop_count then
    chosen_shop = PathData.normal_world_shops[shop_index + 1]
  else
    shop_index = shop_index - normal_world_shop_count
    chosen_shop = PathData.all_world_shops[shop_index + 1]
  end
else
  shop_index = PathData.shop_index % all_world_shop_count
  chosen_shop = PathData.all_world_shops[shop_index + 1]
end
PathFinder.collected_money = PathFinder.collected_money or 0
PathFinder.last_money = 0
-- add sub trigger to catch lines for drop count
PathFinder.catch_gagged_line = PathFinder.catch_gagged_line or {}
local function extract_money(catched_line)
        local money = catched_line:match("%d+ Muenzen"):match("%d+")
        PathFinder.last_money = money or 0
        if money then
          PathFinder.collected_money = PathFinder.collected_money + money
        end
      end
PathFinder.catch_gagged_line["money_to_vault"] =
  {
    pattern = "Du steckst",
    type = "startswith",
    action = extract_money,
  }
PathFinder.catch_gagged_line["money_to_ground"] =
  {
    pattern = "Du laesst",
    type = "startswith",
    action = extract_money,
  }
--
-- save the node where to are standing at the moment
local current_node = PathData.node_by_id[gmcp.MG.room.info.id]
if current_node then
  -- go to shop, sell everything
  if PathFinder:go(current_node, chosen_shop, false, false, true) then
    send("verkaufe alles in mir", false)
    -- go to your house to drop the money
    PathFinder:go(chosen_shop, "haus", false, false, current_node == "haus")
    send("oeffne tresor", false)
    send("lege muenzen in mir in tresor", false)
    -- in case the tresor is full:
    send("lass muenzen in mir fallen", false)
    PathFinder.post_run_action = PathFinder.post_run_action or {}
    PathFinder.post_run_action["drop_count"] =
      function()
        iprint(
          {
            f("Du hast {PathFinder.last_money} Gold erhalten,"),
            f("insgesamt {PathFinder.collected_money} Gold."),
          },
          "WS"
        )
      end
    -- go back to last position:
    if current_node ~= "haus" then
      PathFinder:go("haus", current_node)
    end
    -- prepare for next round
    PathData.shop_index =
      (PathData.shop_index + 1) % (all_world_shop_count + normal_world_shop_count)
  else
    eprint(f("Fehler beim Laufen zum Shop '{chosen_shop}'."), "WS")
  end
else
  eprint("Der Raum ist kein Knoten.", "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#shop$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Rieseninsel-Drops</name>
				<script>local current_node = PathData.node_by_id[gmcp.MG.room.info.id]
if current_node then
  if PLAYER and PLAYER.para &gt; 0 then
    eprint("In der Para-Welt gibt es keine Drops auf der Rieseninsel", "WS")
  else
    PathFinder.drop_count = 0
    -- add sub trigger to catch lines for drop count
    PathFinder.catch_gagged_line = PathFinder.catch_gagged_line or {}
    PathFinder.catch_gagged_line["drop_count"] =
      {
        pattern = "Du bedienst Dich aus der Bonbonniere und nimmst ein Drops heraus,",
        type = "startswith",
        action =
          function()
            PathFinder.drop_count = PathFinder.drop_count + 1
          end,
      }
    --
    PathFinder:go(current_node, "p30", false, false, true)
    -- go to shop
    for _, dir in ipairs({"s", "w", "nw", "n", "nw", "n", "o"}) do
      send(dir, false)
    end
    -- take four times drops
    for i = 1, 4, 1 do
      send("bediene mich", false)
    end
    -- go back to portal
    for _, dir in ipairs({"w", "s", "so", "s", "so", "o", "n"}) do
      send(dir, false)
    end
    -- add action to print the count of gathered drops
    PathFinder.post_run_action = PathFinder.post_run_action or {}
    PathFinder.post_run_action["drop_count"] =
      function()
        iprint(f("Du hast {PathFinder.drop_count} Drop(s) geholt."))
      end
    -- go back to start node
    PathFinder:go("p30", current_node)
  end
else
  eprint("Raum ist kein Knotenpunkt", "WS")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#sdrops$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>Syntaxhilfe</name>
			<script>PathFinder:syntax_help()</script>
			<command></command>
			<packageName></packageName>
			<regex>^#WS$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>PathData:load</name>
			<packageName></packageName>
			<script>PathData = PathData or {}

local server, _, _ = getConnectionInfo()

local node_file = f("Wegeskript_{server}_Knoten")
local edge_file = f("Wegeskript_{server}_Kanten")
local portal_file = f("Wegeskript_{server}_nutzbare_Portale")
local alias_file = f("Wegeskript_{server}_Aliases")
local gag_file = f("Wegeskript_{server}_Gags")

function PathData:load()
  --
  -- nodes
  iprint("Lade Daten fuer den Wegskript.", "WS")
  self.node = table.unfold(mload_jsonl(node_file) or {}, "name")
  self.node_by_id = {}
  for name, props in pairs(self.node) do
    for _, id in pairs(props.ids) do
      self.node_by_id[id] = name
    end
  end
  --
  -- edges
  self.edge = table.unfold(mload_jsonl(edge_file) or {}, "id")
  self.neighbour = {}
  self.max_edge_id = -1
  for id, props in pairs(self.edge) do
    -- use newst weight function
    props.weight = PathCreator:compute_weight(props.path)
    --
    -- save neighbour information
    if not self.neighbour[props.start_node] then
      self.neighbour[props.start_node] = {}
    end
    self.neighbour[props.start_node][props.end_node] = id
    --
    -- catch maximal edge id
    self.max_edge_id = math.max(self.max_edge_id, id)
  end
  --
  -- load usable portals
  self.portals = pload_json(portal_file) or self.portals
  --
  -- load individual aliases
  
  self.aliaseddir = mload_tlines(alias_file) or self.aliaseddir
end

registerAnonymousEventHandler("force_reload_path_data", "PathData:load")

function PathData:save()
  msave_jsonl(node_file, table.fold(self.node, "name"))
  msave_jsonl(edge_file, table.fold(self.edge, "id"))
  msave_tlines(alias_file, self.aliaseddir)
  psave_json(portal_file, PathData.portals)
  iprint("Alle Daten wurden gespeichern.", "WS")
  -- all **other** profils have to reload the data
  raiseGlobalEvent("force_reload_path_data")
end
</script>
			<eventHandlerList>
				<string>sysLoadEvent</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Core</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--                                             --
--      Basic structure of the pathfinder      --
--                    ~ by ~                   --
--                   Mundron                   --
--                                             --
-------------------------------------------------
--
-- class to create pathes and nodes
PathCreator = PathCreator or {}
-- class to edit existing pathes and nodes
PathEditor = PathEditor or {}
-- class to run from node to node
PathFinder = PathFinder or {}
--
-- class for all data 
PathData = PathData or {}
--
PathData.shortendir = PathData.shortendir or
  {
    norden = "n",
    nordosten = "no",
    osten = "o",
    suedosten = "so",
    sueden = "s",
    suedwesten = "sw",
    westen = "w",
    nordwesten = "nw",
  }
--
PathData.oppositedirection = PathData.oppositedirection or
  {
    norden = "sueden",
    n = "s",
    nordunten = "nordoben",
    nordoben = "nordunten",
    nordosten = "suedwesten",
    no = "sw",
    nordostoben = "suedwestunten",
    nordostunten = "suedwestoben",
    osten = "westen",
    o = "w",
    ostunten = "westoben",
    ostoben = "westunten",
    suedosten = "nordwesten",
    so = "nw",
    suedostoben = "nordwestunten",
    suedostunten = "nordwestoben",
    sueden = "norden",
    s = "n",
    suedunten = "nordoben",
    suedoben = "nordunten",
    suedwesten = "nordosten",
    sw = "no",
    suedwestunten = "nordostoben",
    suedwestoben = "nordostunten",
    westen = "osten",
    w = "o",
    westunten = "ostoben",
    westoben = "ostunten",
    nordwesten = "suedosten",
    nw = "so",
    nordwestoben = "suedostunten",
    nordwestunten = "suedostoben",
    oben = "unten",
    ob = "unten",
    unten = "oben",
    u = "oben",
  }
--
PathData.aliaseddir = PathData.aliaseddir or
  {
    "n",
    "norden",
    "nordunten",
    "nordoben",
    "no",
    "nordosten",
    "nordostunten",
    "nordostoben",
    "o",
    "osten",
    "ostunten",
    "ostoben",
    "so",
    "suedosten",
    "suedostunten",
    "suedostoben",
    "s",
    "sueden",
    "suedunten",
    "suedoben",
    "sw",
    "suedwesten",
    "suedwestunten",
    "suedwestoben",
    "w",
    "westen",
    "westunten",
    "westoben",
    "nw",
    "nordwesten",
    "nordwestunten",
    "nordwestoben",
    "ob",
    "oben",
    "u",
    "unten",
    "raus",
  }
--
PathData.dirtokey = {8, 9, 6, 3, 2, 1, 4, 7}
--
PathData.portals = PathData.portals or
  {
    p0 = false,
    p1 = false,
    p2 = false,
    p3 = false,
    p4 = false,
    p5 = false,
    p6 = false,
    p7 = false,
    p8 = false,
    p9 = false,
    p10 = false,
    p11 = false,
    p12 = false,
    p13 = false,
    p14 = false,
    p15 = false,
    p16 = false,
    p17 = false,
    p18 = false,
    p19 = false,
    p20 = false,
    p21 = false,
    p22 = false,
    p23 = false,
    p24 = false,
    p25 = false,
    p26 = false,
    p27 = false,
    p28 = false,
    p29 = false,
    p30 = false,
    p31 = false,
    p32 = false,
    p33 = false,
    p34 = false,
    p36 = false,
    p37 = false,
    p38 = false,
    p39 = false,
    p40 = false,
  }
--
PathData.help_lines = PathData.help_lines or {
    {"Zu einem Knoten laufen oder Weg vorbereiten:\n", "l"},
    {"#go", "y"}, {"&lt;Knotenname&gt;\n", "g"},
    {"#run", "y"}, {"&lt;Startknoten&gt;?", "o"}, {"&lt;Endknoten&gt;\n", "g"},
    {"#rerun\n", "y"},
    {"#prepare", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n", "g"},
    {"#reprepare", "y"}, {"&lt;Startknoten&gt;? &lt;Endknoten&gt;?\n", "o"},
    {"Neue Wege oder Knoten erstellen:\n", "l"},
    {"#wa start|ziel|stop|weiter", "y"},
    {"#addnode", "y"}, {"&lt;Knotenname&gt;", "g"}, {":&lt;Titel&gt;?\n", "o"},
    {"#addbounaries", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n", "g"},
    {"#wait", "y"}, {"&lt;Zeit in Sekunden&gt;\n", "g"},
    {"#blocker", "y"}, {"&lt;NPC Name&gt;:&lt;1. Zeile Knuddel&gt;:&lt;1. Zeile Tod&gt;\n", "g"},
    {"#vor", "y"}, {"&lt;beliebiges Kommando&gt;\n", "g"},
    {"#showrecord", "y"}, {"&lt;Anzahl letzten Schritte&gt;?\n", "o"},
    {"#deleterecord", "y"}, {"&lt;Anzahl letzten Schritte&gt;?\n", "o"},
    {"#sweg", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n", "g"},
    {"#seinbahn", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n\n", "g"},
    {"Knoten und Wege anzeigen und aendern:\n", "l"},
    {"#shownode", "y"}, {"&lt;Knotenname&gt;?\n", "o"},
    {"#searchnode", "y"}, {"&lt;Suchtext&gt;\n", "g"},
    {"#addtitle", "y"}, {"&lt;Knotenname&gt;:&lt;Titel&gt;\n", "g"},
    {"#addid", "y"}, {"&lt;Knotenname&gt;\n", "g"},
    {"#deleteid", "y"}, {"&lt;Knotenname&gt;", "g"}, {"&lt;ID-Nummer&gt;?\n", "l"},
    {"#showpath", "y"}, {"&lt;Pfad-ID&gt;\n", "g"},
    {"#computepath", "y"}, {"&lt;Startknoten&gt; &lt;Endknoten&gt;\n", "g"},
    {"#deletepath", "y"}, {"&lt;Pfad-ID&gt;\n\n", "g"},
    {"Einstellungen fuer Wegaufzeichnung oder Wegnutzung:\n", "l"},
    {"#showaliases\n", "y"},
    {"#addalias", "y"}, {"&lt;Neuer Alias&gt;\n", "g"},
    {"#deletealias", "y"}, {"&lt;Alias-ID&gt;\n", "g"},
    {"#showportals\n", "y"},
    {"#flipportal", "y"}, {"&lt;Portalnumber&gt;\n", "g"},
    {"#catchportals\n\n", "y"},
  }
  
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>patheditor</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--
--
--
-------------------------------------------------

function PathEditor:search_node(text)
  local lowered_text = text:lower()
  local result = {}
  for node_name, node_props in pairs(PathData.node) do
    if node_props.title and substring(node_props.title:lower(), lowered_text) then
      table.insert(result, {node_name=node_name, title=node_props.title})
    end
  end
  if table.size(result) == 1 then
    self:show_node(result[1].node_name)
  elseif table.size(result) &gt; 1 then
    local text={f("Es wurden folgende Knoten gefunden, die '{node_name}' im Titel beinhalten:\n")}
    for _,candidate in pairs(real_name) do
      table.insert(text, "Knotenname:")
      table.insert(text, {candidate.node_name, "y"})
      table.insert(text, f("mit dem Titel\n   '{candidate.title}'\n"))
    end
    iprint(text, "WS")
    return
  elseif type(real_name) == "string" then
    node = PathData.node[real_name]
  else
    eprint(f("Es wurde kein Knoten gefunden, welcher '{node_name}' im Titel beinhaltet."), "WS")
    return
  end
end

function PathEditor:show_node(node_name)
  if not node_name then
    local room_id = gmcp.MG.room.info.id
    if len(room_id) == 0 then
      eprint(
        {
          "Kein Knotennamen gegeben und der Raum hat keine Id",
          "um einen Knoten ausfindig zu machen.",
        },
        "WS"
      )
      return
    else
      node_name = PathData.node_by_id[room_id]
      if not node_name then
        eprint("Kein Knotenname gegeben und der Raum ist auch kein Knoten.", "WS")
        return
      end
    end
  end
  local node = PathData.node[node_name]
  if not node then
    eprint(f("Es gibt keinen Knoten mit dem Namen '{node_name}'."), "WS")
    return  
  end
  local neighbours = PathData.neighbour[node_name]
  local description = f("Der Knoten '{node_name}' hat")
  if node.title then
    description = f("{description} den Titel\n   '{node.title}'\n\n")
  else
    description = f("{description} keinen Titel.\n\n")
  end
  if len(node.ids) == 0 then
    description = f("{description}Es sind keine Raum-IDs gespeichert.\n\n")
  else
    description = f("{description}Folgende Raum-IDs sind gespeichert:\n")
    for pos, room_id in ipairs(node.ids) do
      description = f("{description}   {pos}: {room_id}\n")
    end
  end
  if not neighbours then
    description = f("{description}\nGaenzlich und gar, nicht mal ein Nachbar ist da!\n")
  else
    description = f("{description}\nFolgende Nachbar sind von hier zu erreichen:\n")
    if node_name:match("p%d+$") then
      -- node is a portal node
      description = f("{description}   Alle erreichbaren Portale, siehe #showportals\n")
      for neighbour_name, path_id in pairs(neighbours) do
        if not neighbour_name:match("p%d+$") then
          description = f("{description}   {neighbour_name} (Pfad-ID {path_id})\n")
        end
      end
    else
      for neighbour_name, path_id in pairs(neighbours) do
        description = f("{description}   {neighbour_name} (Pfad-ID {path_id})\n")
      end
    end
    
  end
  iprint(description, "WS")
end

function PathEditor:delete_id_from_node(node_name, room_id)
  -- node_name is given, check if the name is valid
  local node_prop = PathData.node[node_name]
  if not node_prop then
    eprint(f("Es gibt keinen Knoten mit dem Namen '{node_name}'."), "WS")
    return
  end
  if room_id then
    -- if room_id is given, it has to be the position in the id-List.
    local old_room_id = PathData.node[node_name].ids[room_id]
    if table.remove_at(PathData.node[node_name].ids, room_id) then
      PathData.node_by_id[room_id] = nil
      iprint(f("Die Room-ID '{old_room_id}' wurde vom Knoten '{node_name}' entfernt."), "WS")
    end
  else
    -- if room_id is missing, use the ID of the current room
    room_id = gmcp.MG.room.info.id
    if len(room_id) == 0 then
      -- A room with an empty id might be a node, but the node
      -- will not have an empty id as id.
      eprint("Der aktuelle Raum hat keine Id, so dass nichts entfernt werden kann.", "WS")
      return
    end
    local real_node_name = PathData.node_by_id[room_id]
    if node_name ~= real_node_name then
      eprint(f("Dieser Raum entspricht dem Knoten '{real_node_node}' und nicht der Eingabe '{node_name}'."), "WS")
      return
    end
    if table.remove_value(PathData.node[node_name].ids, room_id) then
      PathData.node_by_id[room_id] = nil
      iprint(f("Die aktuelle Room-ID '{room_id}' wurde vom Knoten '{node_name}' entfernt."), "WS")
    end
  end
  if main_gui_update_room then
    main_gui_update_room()
  end
  PathData:save()
end


function PathEditor:show_aliases()
  local result = {"Alle Richtungen, die automatisch bei der Wegaufzeichnung erkannt werden:\n"}
  for i = 1, 8, 1 do
    table.insert(result, {f("\n{(i - 1) * 4 + 1} - {i * 4}: "), "y"})
    local dirs = {}
    for j = 1, 4, 1 do
      table.insert(dirs, PathData.aliaseddir[(i - 1) * 4 + j])
    end
    table.insert(result, table.concat(dirs, ", "))
  end
  for i = 0, 1, 1 do
    table.insert(result, {f("\n{33 + 2 * i} + {34 + 2 * i}: "), "y"})
    table.insert(result, 
    PathData.aliaseddir[33 + 2 * i] .. ", " .. PathData.aliaseddir[34 + 2 * i])
  end
  for i = 37, #PathData.aliaseddir, 1 do
    table.insert(result, {f("\n{i}: "), "y"})
    table.insert(result, PathData.aliaseddir[i])
  end
  iprint(result, "WS")
end

function PathEditor:add_alias(subtext)
  if #subtext:gsub("%a+", "") &gt; 0 then
    eprint(
      {
        "Eine Richtung darf nur aus einem Wort bestehen.\n",
        "Fuer Bewegungsaktionen aus mehr als einem Wort muss man den Befehl",
        {"\#vor", "y"},
        "nutzen.",
      },
      "WS"
    )
  else
    -- zuerst testen ob die Richtung nicht bereits in der Liste ist.
    if table.contains(self.aliaseddir, subtext) then
      eprint(f("Die Richtung '{subtext}' steht bereits in der Liste!"), "WS")
    else
      table.insert(self.aliaseddir, subtext)
      iprint(f("Die Richtung '{subtext}' wurde hinzugefuegt."), "WS")
      PathData:save()
    end
  end
end

function PathEditor:delete_alias(number)
  if number &lt; 1 or number &gt; #self.aliaseddir then
    eprint(f("Eine Richtung mit der Nummer {number} existiert nicht."), "WS")
  elseif number &lt; 38 then
    eprint("Die Standard-Richtungen koennen nicht geloescht werden.", "WS")
  else
    local todel = self.aliaseddir[number]
    table.remove_at(self.aliaseddir, number)
    iprint(f("Die Richtung '{todel}' wurde geloescht."), "WS")
    PathData:save()
  end
end

function PathEditor:show_path(path_id)
  local path_props = PathData.edge[path_id]
  if not path_props then
    eprint(f("Es gibt keinen Weg mit der ID {path_id}."), "WS")
    return
  end
  iprint({
    f("Der Weg mit der ID {path_id} geht\n"),
    "   von",
    {path_props.start_node, "y"},
    "nach",
    {path_props.end_node, "y"},
    "\n\nDie einzelnen Schritte sind:\n  ",
    table.concat(path_props.path, "\n   ")
   }, "WS")
end

function PathEditor:show_prepared_path(start_node, end_node)
  local path, node_names, path_ids = PathFinder:prepare_path(start_node, end_node)
  if not path then
    return
  end
  iprint({
      "Der Weg von",
      {start_node, "y"},
      "nach",
      {end_node, "y"},
      "geht entlang\n   ",
      {table.concat(node_names, ' -&gt; '), "b"},
      "\n\n",
      "Die Weg-Ids sind ",
      {table.concat(path_ids, ', '), "y"},
      "\n\nDie einzelnen Schritte sind:\n  ",
      table.concat(path, "\n   ")
    }, "WS")
end

function PathEditor:delete_path(path_id)
  local path_props = PathData.edge[path_id]
  if not path_props then
    eprint(f("Es gibt keinen Weg mit der ID {path_id}."), "WS")
    return
  end
  local confirmation = PathEditor.confirm_path_deletion
  if not confirmation or confirmation ~= path_id then
    iprint({
      f("Willst du wirklich den Weg mit der ID {path_id} \n"),
      "   von",
      {path_props.start_node, "y"},
      "nach",
      {path_props.end_node, "y"},
      "loeschen? Falls ja, wiederhole den Loeschbefehl."
     }, "WS")
     PathEditor.confirm_path_deletion = path_id
  else
    PathData.edge[path_id] = nil
    PathData.neighbour[path_props.start_node][path_props.end_node] = nil
    PathEditor.confirm_path_deletion = nil
    iprint("Der Weg wurde geloescht.", "WS")
    PathData:save()
  end
end

function PathEditor:show_portals()
  local result = {
    "Die Nutzbarkeit der Portale sieht fuer dich wie folgt aus:\n\n",
  }
  -- it is ugly to display the portals this way, but far more useful
  -- and faster storing it as a mapping, which doesn't provide an order
  for i=0,40,1 do
    if i ~= 35 then
      if i &lt; 10 then
        table.insert(result, {f("    P{i}: "), "y"})
      else
        table.insert(result, {f("   P{i}: "), "y"})
      end
      if PathData.portals[f("p{i}")] then
        table.insert(result, {"   nutzbar   ", "g"})
      else
        table.insert(result, {"nicht nutzbar", "r"})
      end
      local title = PathData.node[f("p{i}")].title
      if title then
        table.insert(result, f("({title})\n"))
      else
        table.insert(result, "\n")
      end
    end
  end
  iprint(result, "WS")
end

function PathEditor:flip_portal(nr)
  local portal_name = f("p{nr}")
  if not table.contains(PathData.portals, portal_name) then
    eprint(f("Ein Portal P{nr} gibt es nicht."), "WS")
    return
  end
  PathData.portals[portal_name] = not PathData.portals[portal_name]
  if PathData.portals[portal_name] then
    iprint(f("Das Portal P{nr} ist nun nutzbar."), "WS")
  else
    iprint(f("Das Portal P{nr} ist nicht mehr nutzbar."), "WS")
  end
  PathData:save()
end

function PathEditor:reprepare_path(start_node, end_node)
  if not start_node or not end_node then
    local path_names = {}
    for path_name,_ in pairs(PathData.prepared_path) do
      table.insert(path_names, string.split(path_name, "_"))
    end
    PathData.prepared_path = {}
    for _,path_name in pairs(path_names) do
      PathFinder:prepare_path(unpack(path_name))
    end
    iprint("Alle vorbereiteten Wege wurden neu berechnet.", "WS")
  else 
    PathData.prepared_path[f("{start_node}_{end_node}")] = nil
    PathFinder:prepare_path(start_node, end_node)
    iprint(f("Der Weg von '{start_node}' nach '{end_node}' wurde neu berechnet."), "WS")
  end
end

local function store_portal_lines()
  local current_line = getCurrentLine()
  if isPrompt() then
    killTrigger(PathEditor.portal_catch_trigger_id)
    display(PathEditor.catched_portal_lines)
    PathEditor.portal_catch_trigger_id = nil
    echo("\n\nGefundene Portale:\n")
    for _,line in ipairs(PathEditor.catched_portal_lines) do
      for match in line:gmatch("%d+%. [^(%d%]%[]+") do
        local tab = string.split(match, "%.")
        local portal_nr = tab[1]
        local portal_title = string.strip(tab[2])
        echo(f("{portal_nr}: '{portal_title}'"))
        PathData.portals[f("p{portal_nr}")] = true
        PathData.node[f("p{portal_nr}")].title = portal_title
        echo(" (gespeichert)\n")
      end
    end  
    --
    iprint("Teleportiere zu allen Portalen um die Raum-Ids zu speichern.", "WS")
    PathEditor.portal_to_visit = 0
    enableTimer("catch_portal_room_ids")
  else
    table.insert(PathEditor.catched_portal_lines, getCurrentLine())
  end
end

function PathEditor:catch_portals()
  --
  iprint("Fuege dummy Knoten p0 bis p40 hinzu und alle potentiellen Wege dazwischen.", "WS")
  local edge_id = table.size(PathData.edge)
  for s = 1,40,1 do
    local start_node = f("p{s}")
    if s ~= 35 then
      if not PathData.node[start_node] then
        PathData.node[start_node] = {ids={}}
        for e = 1,40,1 do
          if e ~= s and e ~= 35 then
            local end_node = f("p{e}")
            if not PathData.neighbour[start_node][end_node] then
              local edge = {
                start_node=start_node, 
                end_node=end_node, 
                path={f("teleportiere {e}")}
              }
              table.insert(PathData.edge, edge)
              edge_id = edge_id + 1
              PathData.neighbour[start_node][end_node] = edge_id 
            end
          end
        end
      end 
    end
  end
  --
  iprint("Nun fuege Titel der bekannten Portale hinzu.", "WS")
  --
  PathEditor.catched_portal_lines = {}
  local trigger_id = tempLineTrigger(-1, 30, store_portal_lines)
  PathEditor.portal_catch_trigger_id = trigger_id
  send("teleportiere")
  --
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>pathfinder</name>
			<packageName></packageName>
			<script>local function handle_lines_to_gag()
  if PathFinder.catch_gagged_line then
    local line = getCurrentLine()
    for _,config in pairs(PathFinder.catch_gagged_line) do
      if config.type == "startswith" and string.startswith(line, config.pattern) then
        config.action(line)
      end
    end
  end
  deleteLine()
end

function PathFinder:start_gag_trigger()
  self:kill_gag_trigger("reset due to start")
  send("ultrakurz", false)
  self.all_gag_trigger_id = tempLineTrigger(1, 10000, handle_lines_to_gag)
  tempTrigger("Du bist nun im \"Ultrakurz\"modus.", deleteLine, 1)
  self.walk_in_progress = true
end

local function handle_post_run_actions()
  for _, action in pairs(PathFinder.post_run_action) do
    action()
  end
  PathFinder.catch_gagged_line = {}
  PathFinder.post_run_action = {}
end

function PathFinder:kill_gag_trigger(param)
  if self.walk_in_progress and not self.keep_silence then
    if self.all_gag_trigger_id then
      send("lang", false)
      killTrigger(self.all_gag_trigger_id)
      self.all_gag_trigger_id = nil
      send("schau", false)
      tempTimer(1, handle_post_run_actions)
    end
  end
  self.walk_in_progress = false
end

local function get_next_node(graph)
  local best_node = nil
  local minimal_distance = math.huge
  for name, props in pairs(graph) do
    if not props.visited and props.distance and props.distance &lt; minimal_distance then
      minimal_distance = props.distance
      best_node = name
    end
  end
  return best_node, minimal_distance
end

function PathFinder:get_connection(start_node, end_node)
  -- compute shortest path from start_node to end_node
  -- according the Dijkstra algorithm
  local graph = {}
  for name in pairs(PathData.node) do
    if name == start_node then
      graph[name] = {distance = 0, visited = false}
    else
      -- math.huge is infty
      graph[name] = {distance = math.huge, visited = false}
    end
  end
  local at_node, distance_to_start = get_next_node(graph)
  while at_node do
    -- check neighbours of closest node
    local neighbours = PathData.neighbour[at_node]
    if not neighbours then
      -- eprint(f("Der Knoten '{at_node}' hat keine Nachbarn!"), "WS")
    end
    local at_node_is_portal = at_node:match("p%d+$")
    for neighbour_node, path_id in pairs(neighbours or {}) do
      -- only use non-portal neighbours or usable portals
      if not at_node_is_portal or table.get(PathData.portals, neighbour_node, true) then
        -- special case: Don't use portal 'p8' while being 
        -- in the parallel world: Portal is instable.
        if not (neighbour_node == "p8" and PLAYER and PLAYER.para and PLAYER.para &gt; 0) then
          local path_length = PathData.edge[path_id].weight
          if distance_to_start + path_length &lt; graph[neighbour_node].distance then
            graph[neighbour_node].distance = distance_to_start + path_length
            graph[neighbour_node].previous_node = at_node
            graph[neighbour_node].path_id = path_id
          end
        end
      end
    end
    --
    graph[at_node].visited = true
    if at_node == end_node then
      break
    end
    -- if we didn't reached the goal, go into next round
    at_node, distance_to_start = get_next_node(graph)
  end
  -- Are we successfull?
  if graph[end_node].distance &lt; math.huge then
    -- collect path ids from end_node to start_node
    local node = end_node
    local path_ids = {}
    local node_names = {start_node}
    while node ~= start_node do
      table.insert(path_ids, 1, graph[node].path_id)
      table.insert(node_names, 2, node)
      node = graph[node].previous_node
    end
    -- expand path steps
    path = {}
    for _, path_id in ipairs(path_ids) do
      for _, step in ipairs(PathData.edge[path_id].path) do
        table.insert(path, step)
      end
    end
    --
    return path, node_names, path_ids
  else
    eprint(
      {"Es gibt keine Verbindung zwischen '", {start_node, "y"}, "' und '", {end_node, "y"}, "'."},
      "WS"
    )
  end
end

function PathFinder:clean_trigger_and_timer()
  table.apply(self.blocker_trigger_ids or {}, killTrigger)
  self.blocker_trigger_ids = {}
  table.apply(self.timer_ids or {}, killTimer)
  self.timer_ids = {}
  table.apply(self.enabled_trigger or {}, disableTrigger)
  self.enabled_trigger = {}
end

function PathFinder:walk_stored_path(verbose)
  -- prepare walk
  self.walk_in_progress = true
  if not verbose then
    PathFinder:clean_trigger_and_timer()
    PathFinder:start_gag_trigger()
    verbose = false
  end
  --
  -- get stored data
  local path = self.last_path
  local start_index = self.next_walk_index
  local end_index = len(path)
  if start_index &gt; end_index then
    wprint("Der letzte Weg ist bereits zu Ende gelaufen.", "WS")
  end
  local step
  --
  -- do steps for walk the path
  for i = start_index, end_index, 1 do
    step = path[i]
    self.next_walk_index = i + 1
    if string.startswith(step, "#dopath") then
      --
      -- classical list of single word commands
      local substeps = string.split(step, " ")
      for j = 2, len(substeps), 1 do
        send(substeps[j], verbose)
      end
    elseif string.startswith(step, "#wait") then
      --
      -- timer to continue afterwards
      local delay = tonumber(step:match("%d+"))
      id =
        tempTimer(
          delay,
          function()
            PathFinder:walk_stored_path()
          end
        )
      table.insert(self.timer_ids, id)
      break
    elseif string.startswith(step, "#blocker") then
      --
      -- prepare trigger to kill or to continue
      step = step:sub(len("#blocker ") + 1)
      local npc_name, cuddle_subtext, death_subtext = unpack(string.split(step, ":"))
      kill_id =
        tempRegexTrigger(
          cuddle_subtest,
          function()
            send("schau")
            send(f("toete {npc_name}"))
          end
        )
      table.insert(self.blocker_trigger_ids, kill_id)
      miss_id =
        tempTrigger(
          "Knuddle wen?",
          function()
            PathFinder:walk_stored_path()
          end
        )
      table.insert(self.blocker_trigger_ids, miss_id)
      die_id =
        tempRegexTigger(
          death_subtext,
          function()
            PathFinder:walk_stored_path()
          end
        )
      table.insert(self.blocker_trigger_ids, die_id)
      table.insert(
        self.timer_ids,
        tempTimer(
          0.5,
          function()
            PathFinder:walk_stored_path()
          end
        )
      )
      break
    elseif string.startswith(step, "#trigger") then
      --
      -- enable prepared trigger
      local trigger_name = step:sub(len("#trigger ") + 1)
      enableTrigger(trigger_name)
      table.insert(self.enabled_trigger, trigger_name)
      break
    elseif step ~= "#nop" then
      send(step, verbose)
    end
  end
  if self.next_walk_index &gt; end_index then
    -- in this case, we went through the loop without a break
    PathFinder:clean_trigger_and_timer()
  end
  -- stop or finish walk
  if not verbose and not self.keep_silence then
    if PLAYER then
      local action = "stolpert beim Abbremsen."
      tempTrigger(f("{PLAYER.name} {action}"), function() PathFinder:kill_gag_trigger() end)
      send(f("\\:{action}"), false)
    else
      tempTimer(0.5, function() PathFinder:kill_gag_trigger() end)
      --tempTimer(0.5, function() send("schau", false) end)
    end
  end
end

function PathFinder:prepare_path(start_node, end_node)
  -- sanitycheck for input
  if not start_node then
    eprint("Der Startknoten ist 'nil'.", "WS")
    return
  end
  if not PathData.node[start_node] then
    eprint({"Der Startknoten '", {start_node, "y"}, "' ist unbekannt."}, "WS")
    return
  end
  if not end_node then
    eprint("Der Endknoten ist 'nil'.", "WS")
    return
  end
  if not PathData.node[end_node] then
    eprint({"Der Endknoten '", {end_node, "y"}, "' ist unbekannt."}, "WS")
    return
  end
  if start_node == end_node then
    wprint({"Start- und Endknoten sind identisch '", {start_node, "y"}, "'."}, "WS")
    return
  end
  local path_name = f("{start_node}_{end_node}")
  -- check if we already save this path. If not, we compute the best path
  local path, node_names, path_ids = unpack(PathData.prepared_path[path_name] or {})
  if not path then
    path, node_names, path_ids = self:get_connection(start_node, end_node)
    if not path then
      -- if get_connection returns nil, there was already an error message
      return
    end
    PathData.prepared_path[path_name] = {path, node_names, path_ids}
  end
  return path, node_names, path_ids
end

function PathFinder:go(start_node, end_node, blindly, verbose, keep_silence)
  if blindly then
    if not self.last_targeted_node then
      eprint(
        {
          "Der Wegeskript wurde seit Profilstart noch nicht genutzt. ",
          "Blindes Laufen erfordert Start- und Endknoten. ",
          "Benutze dazu ",
          {"#go &lt;Startknoten&gt; &lt;Endknoten&gt;", "y"},
          ".",
        },
        "WS"
      )
    else
      start_node = self.last_targeted_node
    end
  elseif not start_node then
    start_node = PathData.node_by_id[gmcp.MG.room.info.id]
    if not start_node then
      eprint("Der Raum ist kein definiter Knoten.", "WS")
      return
    end
  end
  local path, node_names, path_ids = self:prepare_path(start_node, end_node)
  if not path then
    return
  end
  iprint(
    {
      "Laufe von ",
      {start_node, "y"},
      " nach ",
      {end_node, "y"},
      " ueber ",
      {table.concat(node_names, ' -&gt; '), "b"},
      ".\n",
      f("Die Weg-Ids sind {table.concat(path_ids, ', ')}."),
    },
    "WS"
  )
  self.last_path = path
  self.last_path_data = {start_node, end_node, path, node_names, path_ids}
  self.last_path_name = f("{start_node}_{end_node}")
  self.next_walk_index = 1
  self.keep_silence = keep_silence
  self.last_targeted_node = end_node
  self.last_targeted_node_ids = PathData.node[end_node].ids
  self:walk_stored_path(verbose)
  return true
end

function PathFinder:show_last_runned_path()
  local start_node, end_node, path, node_names, path_ids = unpack(PathFinder.last_path_data or {})
  if not path then
    eprint("Du bist noch keinen Weg gelaufen.", "WS")
  end
  iprint({
      "Der Weg von",
      {start_node, "y"},
      "nach",
      {end_node, "y"},
      "geht entlang\n   ",
      {table.concat(node_names, ' -&gt; '), "b"},
      "\n\n",
      "Die Weg-Ids sind ",
      {table.concat(path_ids, ', '), "y"},
      "\n\nDie einzelnen Schritte sind:\n  ",
      table.concat(path, "\n   ")
    }, "WS")
end

function PathFinder:syntax_help()
  iprint(PathData.help_lines, "WS")  
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initialize_path_scripts</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function initialize_path_scripts()
  if not PathData.loaded then
    PathData:load()
    PathData.loaded = true
    -- disable old path scripts:
    disableAlias("Wegeskript")
    disableScript("Wegeskript")
  end
end</script>
			<eventHandlerList>
				<string>sysLoadEvent</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>pathcreator - setup</name>
			<packageName></packageName>
			<script>function PathCreator:start()
  self.cpforth = {}
  self.cpback = {}
  self.goback = false
  -- wir starten mit dem Hinweg
  self.startid = gmcp.MG.room.info.id
  if len(self.startid) == 0 then
    wprint("Dieser Raum hat keine Raum-ID und kann nur mit blindem Laufen als Startknoten benutzt werden.", "WS")
  end
  self:create_alias()
  self:create_keys()
  self.recording = true
  iprint("Wegaufzeichnung Typ gestartet.", "WS")
end

function PathCreator:create_alias()
  self:kill_alias()
  for _, v in pairs(PathData.aliaseddir) do
    table.insert(self.alias_ids, tempAlias(f("^{v}$"), f("PathCreator:move_forth('{v}')")))
  end
end

function PathCreator:kill_alias()
  table.apply(self.alias_ids or {}, killAlias)
  self.alias_ids = {}
end

function PathCreator:create_keys()
  -- bind keypad keys to directions to allow fast
  -- moving using the keypad
  self:kill_keys()
  for i = 1, 8, 1 do
    -- key binding for north, northeast, ... (element 2, 6, 10, ...)
    local code_to_apply =  f("PathCreator:move('{PathData.aliaseddir[i * 4 - 2]}')")
    --echo(f("{code_to_apply}\n"))
    local key_id = tempKey(
        mudlet.keymodifier.Keypad,
        mudlet.key[tostring(PathData.dirtokey[i])],
        code_to_apply
      )
    table.insert(
      self.key_ids,
      key_id
    )
    -- key binding for north up, northeast up, ... (element 3, 7, 11, ...)
    table.insert(
      self.key_ids,
      tempKey(
        mudlet.keymodifier.Keypad + mudlet.keymodifier.Control,
        mudlet.key[tostring(PathData.dirtokey[i])],
        f("PathCreator:move('{PathData.aliaseddir[i * 4 - 1]}')")
      )
    )
    -- key bindung for north down, northeast down, ... (element 4, 8, 12, ...)
    table.insert(
      self.key_ids,
      tempKey(
        mudlet.keymodifier.Keypad + mudlet.keymodifier.Alt,
        mudlet.key[tostring(PathData.dirtokey[i])],
        f("PathCreator:move('{PathData.aliaseddir[i * 4]}')")
      )
    )
  end
  -- key binding for up movement
  table.insert(
    self.key_ids,
    tempKey(mudlet.keymodifier.Keypad, mudlet.key.Minus, "PathCreator:move('oben')")
  )
  -- key binding for down movement
  table.insert(
    self.key_ids,
    tempKey(mudlet.keymodifier.Keypad, mudlet.key.Plus, "PathCreator:move('unten', false)")
  )
  -- key binding for leave movement
  table.insert(
    self.key_ids,
    tempKey(mudlet.keymodifier.Keypad, mudlet.key.Asterisk, "PathCreator:move('raus', false)")
  )
end

function PathCreator:kill_keys()
  table.apply(self.key_ids or {}, killKey)
  self.key_ids = {}
end


</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>pathcreator - recording</name>
			<packageName></packageName>
			<script>function PathCreator:stop()
  self:kill_alias()
  self:kill_keys()
  iprint(
    {
      "Wegaufzeichnung angehalten.\n",
      "Du kannst den Hin- und Rueckweg zwischen Start- und Endpunkt mit",
      {"#sweg", "y"},
      "\noder nur den Weg vom Start- zum Endpunkt mit",
      {"#einbahn", "y"},
      "speichern.\nFalls du nur die Aufnahme pausiert, kannst du sie mit",
      {"#wa weiter", "y"},
      "wieder fortsetzen.",
    },
    "WS"
  )
  self.recording = false
end

function PathCreator:continue()
  self:create_keys()
  self:create_alias()
  iprint("Wegaufzeichnung wird fortgesetzt.", "WS")
end

function PathCreator:set_goal()
  local room_id = gmcp.MG.room.info.id
  if len(room_id) == 0 then
    wprint("Dieser Raum hat keine Raum-ID und kann nur mit blindem Laufen als Startknoten benutzt werden.", "WS")
  end
  if not self.goback then
    self.endid = room_id
    self.goback = true
    iprint(
      {
        "Der Raum ist nun als Endpunkt markiert.\n",
        "Falls das ein Fehler war, wiederhole den Befehl",
        {"#wa ziel", "y"},
        "um weiter vorwaerts zum Ziel zu laufen.\nAndernfalls kannst du entweder mit",
        {"#wa stop", "y"},
        "die Aufzeichnung stoppen und den Weg vom Start- zum Endpunkt mit",
        {"#einbahn", "y"},
        "speichern\noder die Aufzeichnung nun vom End- zum Startpunkt fortfuehren,",
        "sie dann am Startpunkt beenden und den Weg vom Start- zum Endpunkt",
        "und zurueck mit",
        {"#sweg", "y"},
        "speichern.",
      },
      "WS"
    )
  elseif self.endid == room_id then
    self.goback = false
    iprint(
      {
        "Die Markierung dieses Raum als Ziel ist wieder aufgehoben.\n",
        "Du kannst nun weiter vorwaerts zum Ziel hin aufzeichnen.",
      },
      "WS"
    )
  else
    eprint("Um die Zielmarkierung aufzuheben muss dies im Zielraum geschehen.", "WS")
  end
end

function PathCreator:show_last(num)
  local cpback_len = len(self.cpback)
  local cpforth_len = len(self.cpforth)
  num = num or (cpback_len + cpforth_len)
  local cpback_size = math.min(num, cpback_len)
  local cpforth_size = math.min(math.max(num - cpback_size, 0), cpforth_len)
  local result = {}
  if self.startid == gmcp.MG.room.info.id then
    table.insert(result, f("Startknoten mit der Raum-ID {self.startid}\n"))
  end
  for i = 1, cpback_size, 1 do
    table.insert(result, f("-{i}: {self.cpback[cpback_size - i + 1]}\n"))
  end
  if num &gt; cpback_len then
    table.insert(result, f("Zielknoten mit der Raum-ID {self.endid}\n"))
  end
  for i = 1, cpforth_size, 1 do
    table.insert(result, f("-{cpback_size+i}: {self.cpforth[cpforth_size - i + 1]}\n"))
  end
  if cpforth_size == cpforth_len then
    table.insert(result, f("Startknoten mit der Raum-ID {self.startid}\n"))
  end
  iprint(result, "WS")
end

function PathCreator:delete_last(num)
  if self.goback then
    local cpback_len = len(self.cpback)
    num = num or cpback_len
    if num &lt; cpback_len then
      self.cpback = table.subtable(self.cpback, 1, cpback_len - num)
      iprint(f("Die letzten {num} Eintraege fuer den Rueckweg wurden geloescht."), "WS")
    elseif num == cpback_len then
      self.cpback = {}
      iprint(f("Alle {num} Eintraege fuer den Rueckweg wurden geloescht."), "WS")
    else
      self.cpback = {}
      iprint(
        {
          f("Alle {cpback_len} Eintraege fuer den Rueckweg wurden geloescht. "),
          "Sollen auch Eintraege zum Zielknoten hin geloescht werden, ",
          "Musst du das Ziel mit ",
          {"#wa ziel", "y"},
          " wieder aufloesen und dann die entsprechende Anzahl loeschen.",
        },
        "WS"
      )
    end
  else
    local cpforth_len = len(self.cpforth)
    num = num or cpforth_len
    if num &lt; cpforth_len then
      self.cpforth = table.subtable(self.cpforth, 1, cpforth_len - num)
      iprint(f("Die letzten {num} Eintraege fuer den Hinweg zum Ziel wurden geloescht."), "WS")
    else
      self.cpforth = {}
      iprint(f("Alle {cpforth_len} Eintraege seit dem Startknoten wurden geloescht."), "WS")
    end
  end
end

function PathCreator:move_forth(dir, dont_send)
  if self.recording then
    if self.goback then
      table.insert(self.cpback, dir)
    else
      table.insert(self.cpforth, dir)
    end
    if not dont_send then
      send(dir, false)
    end
    return true
  else
    eprint("Es ist keine Wegaufzeichnung aktiv.", "WS")
    return false
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>pathcreator - saving</name>
			<packageName></packageName>
			<script>local function simplifypath(commands)
  -- we shorten the main directions and
  -- remove redundancy like forth and back
  -- this is done in line!!!
  for i = 1, #commands, 1 do
    if PathData.shortendir[commands[i]] then
      commands[i] = PathData.shortendir[commands[i]]
    end
  end
  for i = 1, #commands - 1, 1 do
    while PathData.oppositedirection[commands[i]] == commands[i + 1] do
      table.remove(commands, i + 1)
      table.remove(commands, i)
      if i &gt; 0 then
        i = i - 1
      end
    end
  end
end

local function groupdirections(commands)
  -- To improve readablitity one word commands
  -- are put together into a #dopath command
  local numstr = 0
  local result = {}
  if #commands == 1 then
    result = commands
  elseif #commands &gt; 1 then
    for i = 1, #commands, 1 do
      _, numstr = commands[i]:gsub("%S+", "")
      if numstr == 1 then
        -- single word commands are combined into one string
        if len(result) &gt; 0 and string.startswith(result[len(result)], "#dopath") then
          -- add to last #dopath
          result[len(result)] = f("{result[len(result)]} {commands[i]}")
        else
          -- start a #dopath
          table.insert(result, f("#dopath {commands[i]}"))
        end
      else
        -- multi word commands get an own entry
        table.insert(result, commands[i])
      end
    end
  end
  -- if last command is a wait, trigger or timer, we add a no-op command
  display(result)
  display(len(result))
  local last_command = result[len(result)]
  display(last_command)
  if
    string.startswith(last_command, "#wait") or
    string.startswith(last_command, "#blocker") or
    string.startswith(last_command, "#trigger")
  then
    table.insert(result, "#nop")
  end
  return result
end

local function clean_path(commands)
  simplifypath(commands)
  return groupdirections(commands)
end

function PathCreator:compute_weight(commands)
  -- compute the weight of a path.
  -- Each single word command has a weight of 1
  -- For later:
  -- #trigger, #blocker, #wait will get a higher weight.
  local result = 0
  for _, cmd in pairs(commands) do
    if type(cmd) == "string" then
      if string.startswith(cmd, "#dopath") then
        _, words = cmd:gsub("%S+", "")
        -- remove 1 due to keyword #dopath
        result = result + words - 1
      elseif string.startswith(cmd, "#blocker") then
        result = result + 10
      elseif string.startswith(cmd, "#wait") then
        result = result + 5
      else
        result = result + 1
      end
    else
      -- For later for trigger?
      result = result + 200
    end
  end
  return result
end

function PathCreator:save_new_path(start_node, end_node, bidirectional)
  if self.recording then
    wprint(
      {
        "Die Wegaufzeichnung muss mit",
        {"#wa stop", "y"},
        "beendet werden, bevor der aufgezeichnete Weg gespeichert werden kann.",
      },
      "WS"
    )
    return
  end
  -- check if the boundary nodes are well defined
  local complete_boundary = true
  if not PathData.node[start_node] then
    wprint(f("Ein Knoten namens '{start_node}' existiert noch nicht."), "WS")
    complete_boundary = false
  elseif len(self.startid) &gt; 0 and not PathData.node_by_id[self.startid] then
    complete_boundary = false
    wprint(
      f("Der Startknoten '{start_node}' hat noch nicht die ID {PathCreator.startid} zugewiesen."),
      "WS"
    )
  end
  if not PathData.node[end_node] then
    wprint(f("Ein Knoten namens '{end_node}' existiert noch nicht."), "WS")
    complete_boundary = false
  elseif len(self.endid) &gt; 0 and not PathData.node_by_id[self.endid] then
    wprint(
      f("Der Endknoten '{end_node}' hat noch nicht die ID {PathCreator.endid} zugewiesen."), "WS"
    )
    complete_boundary = false
  end
  if not complete_boundary then
    iprint(
      {
        "Um die Ids automatisch zuzuweisen und bei Bedarf die Knoten zu erstellen,",
        {f("#addboundries {start_node} {end_node}"), "y"},
        "eingeben und anschliessend das Speichern des Weges wiederholen.",
      },
      "WS"
    )
    return
  end
  --
  -- check if there is already a path from start_node to end_node
  -- in vice versa if we should save both directions
  local start_to_end_id = PathData.neighbour[start_node][end_node]
  if start_to_end_id then
    eprint(f("Es gibt bereits einen Weg von '{start_node}' nach '{end_node}' mit der Pfad-ID {start_to_end_id}."), "WS")
    return
  end
  if bidirectional then
    local end_to_start = PathData.neighbour[end_node][start_node]
    if end_to_start then
      eprint(
        {
          f("Es gibt bereits einen Weg von '{end_node}' nach '{start_node}' mit der Pfad-ID {end_to_start}.\n"),
          "Du kannst den Weg '{start_node}' nach '{end_node}' einzeln mit",
          {f("#seinbahn {start_node} {end_node}"), "y"},
          "speichern.",
        },
        "WS"
      )
      return
    end
  end
  --
  -- Finally add path(es)
  local edge_id = PathData.max_edge_id + 1
  PathData.edge[edge_id] =
    {
      start_node = start_node,
      end_node = end_node,
      path = clean_path(self.cpforth),
      weight = PathCreator:compute_weight(self.cpforth),
    }
  PathData.neighbour[start_node][end_node] = edge_id
  iprint(f("Der Weg von '{start_node}' nach '{end_node}' wurde mit der Pfad-ID {edge_id} gespeichert."), "WS")
  if bidirectional then
    edge_id = edge_id + 1
    PathData.edge[edge_id] =
      {
        start_node = end_node,
        end_node = start_node,
        path = clean_path(self.cpback),
        weight = PathCreator:compute_weight(self.cpback),
      }
    PathData.neighbour[end_node][start_node] = edge_id
  iprint(f("Der Weg von '{end_node}' nach '{start_node}' wurde mit der Pfad-ID {edge_id} gespeichert."), "WS")
  end
  PathData.max_edge_id = edge_id
  PathData:save()
end

function PathCreator:add_boundaries(start_name, end_name)
  self:add_node(start_name, self.startid, true)
  self:add_node(end_name, self.endid, true)
  PathData:save()
end

function PathCreator:add_node(name, room_id, dontsave)
  if not room_id then
    room_id = gmcp.MG.room.info.id
  end
  if len(room_id) == 0 then
    wprint("Knoten hat leere Raum-ID.", "WS")
    if not PathData.node[name] then
      PathData.node[name] = {ids = {}}
      PathData.neighbour[name] = {ids = {}}
      iprint(
        f("Ein Knoten mit dem Namen '{name}' existiert noch nicht und wurde ohne ID angelegt."),
        "WS"
      )
    else
      wprint(
        f("Der Knoten mit dem Namen '{name}' existiert bereits. Es wurde nichts geaendert."), "WS"
      )
    end
  else
    -- room_id is valid
    --
    local node_name = PathData.node_by_id[room_id]
    if node_name then
      if not (node_name == name) then
        eprint(f("Die Raum-ID wurde schon zum Knoten '{node_name}' gespeichert!"), "WS")
        return
      end
    else
      PathData.node_by_id[room_id] = name
    end
    --
    local node_props = PathData.node[name]
    if not node_props then
      PathData.node[name] = {ids = {room_id}}
      PathData.neighbour[name] = {ids = {}}
      iprint(f("Der Knoten '{name}' wurde mit der Raum-Id {room_id} angelegt."), "WS")
    elseif table.contains(node_props.ids, room_id) then
      wprint(f("Die Raum-Id ist bereits zum Knoten '{name}' gespeichert."), "WS")
    else
      table.insert(node_props.ids, room_id)
      iprint(f("Die Raum-Id {room_id} ist nun zum Knoten '{name}' hinzugefuegt."), "WS")
    end
  end
  if main_gui_update_room then
    main_gui_update_room()
  end
  if not dontsave then
    PathData:save()
  end
end

function PathCreator:add_node_title(name, title, force)
  local node = PathData.node[name]
  if not node then
    eprint(f("Es gibt noch keinen Knoten mit dem Namen '{name}'."), "WS")
    return
  end
  if node.title then
    if node.title == title then
      iprint(f("Der Knoten '{name}' hat bereits diesen Titel."), "WS")
    elseif force then
      node.title = title
      iprint(f("Der Titel '{title}' wurde nun dem Knoten '{name}' gesetzt."), "WS")
      PathData:save()
    else
      wprint(
        f(
          "Der Knoten '{name}' hat schon den Titel '{title}'. Zum Updaten kannst du #retitle benutzen."
        ),
        "WS"
      )
    end
  else
    node.title = title
    iprint(f("Der Titel '{title}' wurde nun dem Knoten '{name}' gesetzt."), "WS")
    PathData:save()
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>transform v1 to v2</name>
			<packageName></packageName>
			<script>--------------------------------------------
--
--  This are just needed once to transform
--  pathes from the old version to the new
--  format. You can delete it afterwards
--
--  call
--  lua PathUtil:transform()
--  to transform old PF data to PathData
--  Go to a portal room and call
--  lua PathUtil:add_portals()
--  to add all portal nodes and pathes
--
--  don't forget to call at the end
--  lua PathData:save()
--------------------------------------------

PathUtil = {}

function PathUtil:get_name(go_string)
  local without_go = go_string:sub(5)
  if string.endswith(without_go, "_z") then
    return without_go:sub(1, -3)
  else
    return without_go
  end
end

function PathUtil:transform()
  local node
  iprint("Speicher ids")
  PathData.node = {}
  for id, name in pairs(PF.ids) do
    if string.endswith(name, "_z") then
      iprint(f("Der Rueckweg '{name}' sollte keine ID haben."))
    elseif len(id) == 0 then
      iprint(f("Fehlerhaft leere ID '{id}' beim Knoten '{name}' gespeichert."))
    elseif name == "st" then
      iprint(f("Skip Sandtiger '{name}'"))
    else
      node = PathData.node[name]
      if not node then
        PathData.node[name] = {name=name, ids={id}}
      else
        table.insert(node.ids, id)
      end
    end
  end
  iprint(f("{len(PathData.node)} Knoten wurden erstellt."), "WS")
  --
  iprint("Speicher Titel")
  for start_name, title in pairs(PF.titles) do
    if not string.endswith(start_name, "_z") then
      node = PathData.node[start_name]
      if not node then
        eprint(f("Knoten {start_name} hat keine Id?"), "WS")
        PathData.node[start_name] = {ids={}, title=title:sub(11)}
      else
        if not string.endswith(start_name, "_z") then
          node.title = title:sub(11)  
        end
      end
    end
  end
  iprint("Speicher Wege")
  PathData.edge = {}
  for name, path in pairs(PF.pathes) do
    if len(path) == 0 then
      eprint(f("ERROR, empty path for {name}"))
    elseif name == "st" or name == "st_z" then
      wprint(f("Ignore path {name}"))
    else
      self:save_path(name, table.deepcopy(path))
    end
  end
  iprint("Done", "WS")
end


function PathUtil:save_path(name, path)
  if string.endswith(name, "_z") then
    -- cut off _z at the end
    start_name = name:sub(1, -3)
    if string.startswith(path[#path], "#go") then
      end_name = self:get_name(path[#path])
      -- pop last element from table
      table.remove(path)
    else
      other_direction = PF.pathes[start_name]
      if not other_direction then
        end_name = nil
        eprint(f("Missing '{start_name}'."), "WS")
      elseif string.startswith(other_direction[1], "tele") then
        -- extract portal number by remove all non-digit symbols
        portal, match_number = other_direction[1]:gsub("%D+", "")
        end_name = f("p{portal}")
      else
        end_name = nil
        wprint(f("Fehlender Zielknoten fuer {name}"))
        display(path)
        --do return end
      end
    end
  else
    end_name = name
    if string.startswith(path[1], "#go") then
      start_name = self:get_name(path[1])
      table.remove_at(path, 1)
    elseif string.startswith(path[1], "tele") then
      portal, match_number = path[1]:gsub("%D+", "")
      start_name = f("p{portal}")
      table.remove_at(path, 1)
    else
      eprint(f("Fehlender Startknoten fuer {name}"))
      display(path)
      --do return end
      start_name = nil
    end
  end
  if start_name and end_name then
    table.insert(PathData.edge, {start_node=start_name, end_node=end_name, path=path})
  end
end
  
function PathUtil:add_portals()
  portal = 0
  step = 0
  enableTimer("save_portals")
  for s = 1,40,1 do
    if s ~= 35 then
      for e = 1,40,1 do
        if e ~= s and e ~= 35 then
          local edge = {
            start_node=f("p{s}"), 
            end_node=f("p{e}"), 
            path={f("teleportiere {e}")}
            }
          table.insert(PathData.edge, edge)
          display(edge)
        end
      end 
    end
  end
  iprint("done")
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="no" isFolder="no">
			<name>TODO</name>
			<packageName></packageName>
			<script>local possible_features = [[
  - restrict pathes to life points, magic points and world (positiv "only" or negative "except")
]]
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="no" isFolder="no">
			<name>Neues Skript</name>
			<packageName></packageName>
			<script>Der gewaltige, weisse Skorpion legt sich auf den Ruecken und verendet.

Du knuddelst den gewaltigen, weissen Skorpion. </script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
