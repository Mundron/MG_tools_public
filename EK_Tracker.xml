<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>EKs lesen</name>
			<script>--display(matches[2])
local found_eks = tonumber(matches[2])
--display(EK.current, found_eks, EK.saved, delta)
local delta = found_eks-EK:count()
if delta &lt; 0 then
	GUI.ekanzahl:echo("EK-Anzahl: "..found_eks-delta.."("..delta..")", "black")
elseif delta == 0 then
	GUI.ekanzahl:echo("EK-Anzahl: "..found_eks, "black")
else
	GUI.ekanzahl:echo("EK-Anzahl: "..found_eks-delta.."(+"..delta..")", "black")
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>(\d+)\s+verschiedene Monster getoetet,</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Gag</name>
			<script>selectCurrentLine()
deleteLine()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Traeger dieser ehrenvollen Plakette,</string>
				<string>hat, unter absolut heroischem Einsatz</string>
				<string>seines wertvollen Lebens</string>
				<string>fuer deren Hinscheiden er mit Stufenpunkten</string>
				<string>belohnt wurde.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Plakette zurueckrichten!</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>(\w+) richtet (seine|ihre) Plakette auf Dich.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Auslesen Teil 1</name>
			<script>if matches[2]=="ein" then
	EK.player_hasnt = 1
else
	EK.player_hasnt = tonumber(matches[2])
end

EK:save_plakettenabgleich(matches[4])
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Du hast (\w+) Monster getoetet, (das|die) (\w+) noch nicht getoetet hat.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Auslesen Teil 2</name>
			<script>if matches[3]=="ein" then
	EK.competitor_hasnt = 1
else
	EK.competitor_hasnt = tonumber(matches[3])
end

EK:save_plakettenabgleich(matches[2])
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(\w+) hat (\w+) Monster getoetet, (das|die) Du noch nicht getoetet hast.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Einloggen</name>
			<script>tempTimer(1, function() send("lies plakette") end)</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Verwende Deine alte sterbliche Huelle ...</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>temp</name>
			<script>--display("matched: "..line)

local trigger_name = "Kerbholz"

if not TRIGGER[trigger_name] or not TRIGGER[trigger_name].isOpen then   -- this checks for the first line, and initializes your variables
  TRIGGER[trigger_name] = {text="", len=1, isOpen=true}
end

TRIGGER[trigger_name].text = TRIGGER[trigger_name].text .. line .. " "   -- this appends each line, with a space added in so that you don't get words running together
TRIGGER[trigger_name].len = TRIGGER[trigger_name].len + 1   -- this keeps track of how many lines the trigger is capturing

--display(line)

if line:match("nichts\..*$") or line:match("stark\..*$") or line:match("leicht\..*$") then   -- this checks to see if the current line ends with "gross.", and closes things out
  TRIGGER[trigger_name].len = 0
  TRIGGER[trigger_name].isOpen = false
  tempTimer(1, function() display(TRIGGER[trigger_name].text) end)
  TRIGGER[trigger_name].text = ""
  -- do other stuff here to actually work with all the text you just captured
  -- name, place, region, creator, hint, world

  -- EK.suggestion = {matches[3], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0}

  --local find_result = EK:find({name=matches[3]})
  --if not find_result or find_result == 0  then
    --iprint("Kein Eintrag gefunden. Vorschlag:", "EK-Tracker")
    --local npc_table = {
    --  {"&lt;0,255,0:0,0,0&gt;Name:", "&lt;0,255,0:0,0,0&gt;Ort:", "&lt;0,255,0:0,0,0&gt;Region:", "&lt;0,255,0:0,0,0&gt;Welt:"},
      --{EK.suggestion[1], EK.suggestion[2], EK.suggestion[3], EK.suggestion[6]}
    --}
    --echo("\n")
    --print_table(norm_table(npc_table, -1, 1))
  --end
end

--display(TRIGGER[trigger_name].len)

setTriggerStayOpen(trigger_name, TRIGGER[trigger_name].len)   -- this sets the number of lines for the trigger to capture

--setTriggerStayOpen("Kerbholz", 0)
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Du richtest Dein Kerbholz auf</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>hake EK ab</name>
			<script>if #matches==2 then
	EK:check(tonumber(matches[2]))
elseif #matches==5 then
  EK:check(tonumber(matches[2]), matches[4], true)
else
  if matches[4]=="-f" then
    EK:check(tonumber(matches[2]), nil, true)
  else
    EK:check(tonumber(matches[2]), matches[4])
  end
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EKcheck (\d+)(\s([^\s]+))?(\s-f)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>entferne Haken am EK</name>
			<script>EK:uncheck(tonumber(matches[2]))</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EKuncheck (\d+)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>zeige EK an</name>
			<script>if #matches == 2 then
  EK:find(tonumber(matches[2]))
else
  EK:find(tonumber(matches[2]), tonumber(matches[4]), matches[5])
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EK (\d+)( bis (\d+) (\w+))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>Pass Anzahl unbekannter EKs an</name>
			<script>EK:unknown(tonumber(matches[2]))</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EKunknown (-?\d+)?$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EK Infos anzeigen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>finde EK</name>
				<script>local prop = {}

if matches[3]=="" then
  -- wird nur ein Wort als Suchbegriff eingegeben,
  -- wird automatisch nach dem Namen gesucht, da dies
  -- auch der haeufigste Fall ist.
	prop["name"] = matches[4]
else
  -- andernfalls erstellen wir ein table mit der Property
  -- als key und dem Suchbegriff als Wert.
  prop[matches[3]:lower()] = matches[4]
end

if #matches[5] &gt; 0 then
  for _,pattern in pairs(string.split(matches[5], "&amp;")) do
    if #pattern &gt; 0 then
      split_pattern = string.split(pattern, ":")
      prop[split_pattern[1]:lower()] = split_pattern[2]
    end
  end
end

EK:find(prop)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKfind ((\w+):)?([^:]+)((\&amp;\w+:[^:\&amp;]+)*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>liste Attribute</name>
				<script>EK:find_attr(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKlist (\w+):(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK am Datum anzeigen</name>
				<script>EK:zeige(matches[2], matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKam (\d\d\.\d\d.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK ab Datum anzeigen</name>
				<script>EK:zeige(matches[2], nil)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKab (\d\d\.\d\d.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK bis Datum anzeigen</name>
				<script>EK:zeige(nil, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKbis (\d\d\.\d\d.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK zwischen Daten anzeigen</name>
				<script>EK:zeige(matches[2], matches[3])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKzwischen (\d\d\.\d\d\.\d\d) und (\d\d\.\d\d\.\d\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Plaketteninfo zeigen</name>
				<script>EK:show_friend(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#plakette (\w+)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>EK hinzufuegen/bearbeiten/loeschen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>fuege NPC (kein EK) hinzu</name>
				<script>EK:add(matches[2], matches[3], matches[4],matches[5], matches[6], tonumber(matches[7]) or 0, true)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#NPCadd ([^\|]+)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(\d)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>fuege EK hinzu</name>
				<script>EK:add(matches[2], matches[3], matches[4],matches[5], matches[6], tonumber(matches[7]) or 0)</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKadd ([^\|]+)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(\d)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK loeschen</name>
				<script>EK:delete(tonumber(matches[2]))</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKdel (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>EK verschieben</name>
				<script>EK:sort(tonumber(matches[2]), tonumber(matches[3]))</script>
				<command></command>
				<packageName></packageName>
				<regex>#EKmove (\d+) (\d+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>schnelles NPC hinzufügen</name>
				<script>if matches[2] then
  EK:add(matches[2], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0, true)
elseif EK.suggestion then
  table.insert(EK.suggestion, true)
  EK:add(unpack(EK.suggestion))
  EK.suggestion = nil
else
  eprint("Name oder Vorschlag fehlt fuer die schnelle Eintragung", "EK-Tracker")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#NPCsadd(\s.+)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>schnelles EK hinzufügen</name>
				<script>if matches[2] then
  EK:add(matches[2], gmcp.MG.room.info.short, gmcp.MG.room.info.domain, nil, nil, 0)
elseif EK.suggestion then
  EK:add(unpack(EK.suggestion))
  EK.suggestion = nil
else
  eprint("Name oder Vorschlag fehlt fuer die schnelle Eintragung", "EK-Tracker")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EKsadd(\s.+)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mehrere EKs bearbeiten</name>
				<script>EK:multichange(matches[2], matches[5], matches[6])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EK (\d+(\s(bis\s)?\d+)*) multichange (\w+):(.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ändere Angaben</name>
				<script>EK:change(tonumber(matches[2]), matches[3], matches[4])</script>
				<command></command>
				<packageName></packageName>
				<regex>^#EK (\d+) change (\w+):(.*)$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>fehlende EKs</name>
			<script>EK:missing(matches[3])</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EKmiss(\s(\w+))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>Hilfe</name>
			<script>display(matches)
local verbose=false
if #matches &gt; 1 then
  verbose =true
end
if verbose then
  decho("&lt;255,255,0:0,0,0&gt;#EK\n")
  echo("    Auflistung moeglicher Befehle zur Syntaxuebersicht, ohne Beschreibung\n")
else
  decho("&lt;255,255,0:0,0,0&gt;#EK -v (Befehlsliste mit kurzer Beschreibung)\n")
end
decho("&lt;255,255,0:0,0,0&gt;#EKcheck &lt;ID&gt; &lt;Datum&gt;? -f?\n")
if verbose then
  echo("   markiert als geholten EK, -f zum Ueberschreiben des Datums\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKuncheck &lt;ID&gt;\n")
if verbose then
  echo("    entfernt Markierung als geholten EK)\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID&gt;\n")
if verbose then
  echo("    zeigt den NPC mit der genannten ID an\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKunknown -?&lt;Anzahl&gt;\n")
if verbose then
  echo("    Anzahl unbekannter, geholter EKs\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID&gt; change &lt;Attribut&gt;:&lt;Inhalt&gt;\n")
if verbose then
  echo("    aendere Attribut bei einem NPC\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKfind &lt;Attribut&gt;:?&lt;Suchtext&gt;\n")
if verbose then
  echo("    suche nach NPC dessen Attribut das Suchtext beinhalten (case-insensitive)\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKlist &lt;Attribut&gt;:?&lt;Suchtext&gt;\n")
if verbose then
  echo("    liste alle Attribute auf, die den Suchtext beinhalten  (case-insensitive)\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKam &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs an dem Datum\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKab &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs ab dem Datum\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKbis &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs bis dem Datum\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKzwischen &lt;Datum DD.MM.YY&gt; und &lt;Datum DD.MM.YY&gt;\n")
if verbose then
  echo("    alle geholten EKs zwischen den Daten\n")
end

decho("&lt;255,255,0:0,0,0&gt;#plakette &lt;Konkurentenname&gt;\n")
if verbose then
  echo("    die letzten Eintraege des Plakettenvergleichs mit Konkurenten\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKadd &lt;Name&gt;|&lt;Ort&gt;|&lt;Region&gt;|&lt;Magier&gt;|&lt;Hinweis&gt;|&lt;Para&gt;\n")
if verbose then
  echo("    fuege NPC hinzu. Felder zwischen | koennen frei bleiben, aber alle | muessen gesetzt werden.\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKdel &lt;ID&gt;\n")
if verbose then
  echo("    entferne NPC-Eintrag mit entsprechender ID\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKmove &lt;alte ID&gt; &lt;neue ID&gt;\n")
if verbose then
  echo("    tausche die IDs der beiden Eintraege\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKsadd &lt;Name&gt;?\n")
if verbose then
  echo("    ohne Parameter wird der Vorschlag vom Kerbholz gespeichert.\n")
  echo("    ansonsten wird ein Eintrag mit dem Namen und Raum+Region aus gmcp erstellt.\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID&gt; change &lt;Attribut&gt;:&lt;Inhalt&gt;\n")
if verbose then
  echo("    aendert das Attribut eines Eintrags\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EK &lt;ID1&gt; &lt;ID2&gt; ... &lt;IDn&gt; multichange &lt;Attribut&gt;:&lt;Inhalt&gt;\n")
if verbose then
  echo("    aendert das Attribut aller NPCs mit den IDs gleichzeitig.\n")
  echo("    zwischen den IDs ist 'bis' moeglich um ID-Bereiche anzugeben.\n")
  echo("     z.B. #EK 100 bis 120 multichange region:Gebirge\n")
end

decho("&lt;255,255,0:0,0,0&gt;#EKmiss\n")
if verbose then
  echo("    zeigt die NPC-Eintraege, die noch offene EKs sind.\n")
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EK( -v)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>EK filtern und bearbeiten</name>
			<script>display(matches)

if matches[3]=="" then
	EK:multichange(EK:find("name", matches[4]), matches[5], matches[6])
else
	EK:multichange(EK:find(matches[3], matches[4]), matches[5], matches[6])
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^#EKfilter ((\w+):)?([^:]*) change (\w+):(.*)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>Core</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------

EK = EK or {
  first=true,
	player_hasnt = -1,
	competitor_hasnt = -1,
	attr = {
    name="name",
    ort="place",
    region="region",
    magier="creator",
    hinweis="hint",
    para="world",
    ek="killpoint"
  },
  attr_name = {
    name="Name",
    place="Ort",
    region="Region",
    creator="Magier",
    hint="Hinweis",
    world="Para",
    killpoint="EK"
  }
}</script>
			<eventHandlerList>
				<string>sysLoadEvent</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>load/save</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
function EK:get_attr(attr)
	if attr=="name" then
		return 1
	elseif attr=="ort" then
		return 2
	elseif attr=="region" then
		return 3
	elseif attr=="magier" then
		return 4
	elseif attr=="hinweis" then
		return 5
	elseif attr=="para" then
		return 6
	end
end

function EK:load()
  if not (PLAYER.name == "ABCDEFGHKLM") then
	   self:load_friends()
  end
end

function EK:load_friends()
	local lines
	local temp
	local fname
	lines = pload_csv("Plaketten_Liste")
  self.friends = {}
  if lines then
		for j, sline in ipairs(lines) do
      temp = {}
			fname = sline[1]
			for i=2,#sline do
				table.insert(temp, sline[i])
			end
			if self.friends[fname] then
				table.insert(self.friends[fname], temp)
			else
				self.friends[fname] = {temp}
			end
		end
	end
end

function EK:save_friends()
	local temp = {}
	for k,v in pairs(self.friends) do
		for j,vv in pairs(v) do
			table.insert(temp, {k, unpack(vv)})
		end
	end
	psave_csv("Plaketten_Liste", temp)
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>EK-Listen handling</name>
			<packageName></packageName>
			<script>------------------------------------------------------
--
------------------------------------------------------

function EK:missing(name)
  if not name or #name == 0 then
    name=PLAYER.name
  end
  local npcs = db:fetch_sql(
    self.db.npc,
      [[SELECT npc.position, npc.name, npc.place, npc.world, npc._row_id FROM npc
      LEFT OUTER JOIN
      (
        SELECT kills.npc_row_id FROM kills
        WHERE kills.killer_name=']]..name..[['
      ) AS player_kills
      ON npc._row_id=player_kills.npc_row_id
      WHERE player_kills.npc_row_id IS NULL AND npc.killpoints = 'true']]
  )
  self:_print_npc_list(npcs, "place", false)
  iprint({"Es sind ", {"&lt;255,255,0:0,0,0&gt;", len(npcs)}, " fehlende EKs eingetragen."}, "EK-Tracker")
end

------------------------------------------------------
--
------------------------------------------------------

function EK:count(name)
  return db:aggregate(
    EK.db.kills.killer_name,
    "count",
    db:eq(EK.db.kills.killer_name, name or PLAYER.name)
  )
end

------------------------------------------------------
--
------------------------------------------------------

function EK:find(pattern_dict, end_id, extra)
  if type(pattern_dict) == "number" then
    if end_id and type(end_id) == "number" then
      if pattern_dict &gt; end_id then
        eprint("Start ID muss kleiner sein als End ID.", "EK-Tracker")
        return
      end
      self:_print_npc_list(
        db:fetch(
          self.db.npc,
          db:AND(
            db:gte(self.db.npc.position, pattern_dict),
            db:lte(self.db.npc.position, end_id)
    	    )
        ), self.attr[extra]
      )
    else
      self:_print_npc(
        db:fetch(
          self.db.npc,
          db:eq(self.db.npc.position, pattern_dict)
    	  )
      )
    end
  else
    if not pattern_dict[1] then
      pattern_dict = {pattern_dict}
    end
    for _,prop_group in pairs(pattern_dict) do
      for prop,_ in pairs(prop_group) do
        if not self.attr_name[prop] and not self.attr[prop] and prop ~= "position" then
          eprint({{prop, "y"}, " ist kein gueltiges Attribut eines NPCs."}, "EK-Tracker")
          return
        end
      end
    end
    local npcs = db:fetch(
      self.db.npc,
      self:_get_attr_query(pattern_dict),
      {self.db.npc.position}
  	)
    self:_print_npc_list(
      npcs
    )
    return #npcs
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:check(id, date, overwrite)
	local npc = db:fetch(
    self.db.npc,
    db:eq(self.db.npc.position, id)
  )[1]
  if not npc then
    eprint({"Kein NPC mit der ID ", {id, "y"}, " gefunden."}, "EK-Tracker")
    return
  end
  local kill_entry = self:_kill_entry(npc)
  if kill_entry  then
    if overwrite then
      if date then
        local d, m, y = date:match("(%d+)\.(%d+)\.(%d+)")
        kill_entry.date = os.time{year=2000+y, month=m, day=d}
      else
        kill_entry.date = os.time()
      end
      db:update(EK.db.kills, kill_entry)
      iprint({"EK mit der ID ", {id, "y"}, " hat Datumskorrektur erhalten."}, "EK-Tracker")
    else
      wprint("EK bereits erworben! Zum Ueberschreiben -f benutzen.", "EK-Tracker")
    end
  else
    if date then
      local d, m, y = date:match("(%d+)\.(%d+)\.(%d+)")
      date = os.time{year=2000+y, month=m, day=d}
    else
      date = os.time()
    end
    local success, msg = db:add(
      EK.db.kills,
      {killer_name=PLAYER.name, npc_row_id=npc["_row_id"], date=date}
    )
    if success then
      iprint({"EK mit der ", {id, "y"}, " ist nun abgehakt."}, "EK-Tracker")
      if gmcp.MG.char.base.wizlevel == 1 then
  			send("lies plakette")
  		else
  			GUI.ekanzahl:echo("EK-Anzahl: "..self:count(), "black")
  		end
    else
      eprint("Fehler bei der Eintragung: "..msg, "EK-Tracker")
    end
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:uncheck(id)
	local npc = db:fetch(
    EK.db.npc,
    db:eq(EK.db.npc.position, id)
  )[1]
  if not npc then
    eprint({"Kein NPC mit der ID ", {id, "y"}, " gefunden."}, "EK-Tracker")
    return
  end
  local kill_entry = db:fetch(
    EK.db.kills,
    db:query_by_example(EK.db.kills, {killer_name=PLAYER.name, npc_row_id=npc["_row_id"]})
  )[1]
  if kill_entry then
    db:delete(EK.db.kills, kill_entry)
    iprint({"Der EK mit der ID ", {id, "y"}, " ist nun nicht mehr abgehakt."}, "EK-Tracker")
  else
    wprint("Der EK wurde noch nicht erworben.", "EK-Tracker")
    return
  end
	if gmcp.MG.char.base.wizlevel == 1 then
		send("lies plakette")
	else
		GUI.ekanzahl:echo("EK-Anzahl: "..self:count(), "black")
	end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:add(name, place, region, creator, hint, world, nonkillpoints)
	if not name then
    eprint("Der Eintrag muss wenigstens einen Namen haben.", "EK-Tracker")
  end
  local next_position = db:aggregate(EK.db.npc.position, "max")+1
  local doc = {name=name, position=next_position}
  if place and #place &gt; 0 then
    doc["place"] = place
  end
  if region and #region &gt; 0 then
    doc["region"] = region
  end
  if creator and #creator &gt; 0 then
    doc["creator"] = creator
  end
  if hint and #hint &gt; 0 then
    doc["hint"] = hint
  end
  if world and world &gt; 0 then
    doc["world"] = world
  end
  if nonkillpoints then
    doc["killpoints"] = "false"
  else
    doc["killpoints"] = "true"
  end
  local success, msg = db:add(EK.db.npc, doc)
  if success then
    decho("\n\n&lt;0,255,0:0,0,0&gt;Neu eingetragener EK:\n")
  	self:_print_npc(doc)
  else
    eprint("Fehler beim Speichern in der DB: "..msg, "EK-Tracker")
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:find_attr(attr, sub)
  local result=db:fetch_sql(
    self.db.npc,
    [[SELECT DISTINCT npc.]]..self.attr[attr]..[[ FROM npc
    WHERE npc.]]..self.attr[attr]..[[ LIKE '%]]..sub:lower()..[[%']]
  )
  local keys = {}
	for _,res in pairs(result) do
		table.insert(keys, res[self.attr[attr]])
	end
	table.sort(keys)
  if #keys == 0 then
		iprint("Keine "..string.capitalize(attr).." gefunden.", "EK-Tracker")
	else
  	iprint({"Gefundene "..string.capitalize(attr)..":", "&lt;0,255,0:0,0,0&gt;"}, "EK-Tracker")
  	for i,v in ipairs(keys) do
  		echo(i..": "..v.."\n")
  	end
	end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:unknown(x)
	local unknown = db:aggregate(
    self.db.kills.npc_row_id,
    "count",
    db:AND(
      db:eq(self.db.kills.killer_name, PLAYER.name),
      db:lt(self.db.kills.npc_row_id, 0)
    )
  )
  if not x then
    iprint({"Die Anzahl unbekannter EKs ist ", {unknown, "&lt;0,255,0:0,0,0&gt;"}, "."}, "EK-Tracker")
    return
  end
	local ausgabe = {
    "Die Anzahl unbekannter EKs aendert sich von ",
    {unknown, "&lt;0,255,0:0,0,0&gt;"},
    " zu "}
	local max_unknown_id = db:aggregate(self.db.kills.npc_row_id, "min")
  if x &gt; 0 then
    local new_unknowns = {}
    for v=max_unknown_id-1,max_unknown_id-x,-1 do
      table.insert(new_unknowns,
        {killer_name=PLAYER.name, npc_row_id=v}
      )
    end
    local success, msg = db:add(self.db.kills, unpack(new_unknowns))
    if not success then
      eprint("Fehler beim Aktualisieren der unbekannten EKs: "..msg, "EK-Tracker")
      return
    end
  elseif x &lt; 0 then
    db:delete(
      self.db.kills,
      db:AND(
        db:eq(self.db.kills.killer_name, PLAYER.name),
        db:lt(self.db.kills.npc_row_id, math.min(0, max_unknown_id-x))
      )
    )
  end
  unknown = db:aggregate(
    self.db.kills.npc_row_id,
    "count",
    db:AND(
      db:eq(self.db.kills.killer_name, PLAYER.name),
      db:lt(self.db.kills.npc_row_id, 0)
    )
  )
  table.insert(ausgabe, {known, "&lt;0,255,0:0,0,0&gt;"})
	table.insert(ausgabe, ".")
  iprint(ausgabe, "EK-Tracker")
  if gmcp.MG.char.base.wizlevel == 1 then
		send("lies plakette")
	else
		GUI.ekanzahl:echo("EK-Anzahl: "..self:count(), "black")
	end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:zeige(von, bis)
	if von then
    local d, m, y = von:match("(%d+)\.(%d+)\.(%d+)")
    von = os.time{year=2000+y, month=m, day=d}
  else
    von = 0
  end
  if bis then
    -- we like to get all kill entries even
    -- for the chosen day. So, the upper limit
    -- has to be extended for a day
    local d, m, y = von:match("(%d+)\.(%d+)\.(%d+)")
    bis = os.time{year=y, month=m, day=d} + 24*60*60
  else
    bis = os.time()
  end
  local npcs = db:fetch_sql(
    self.db.npc,
      [[SELECT npc.* FROM npc
      JOIN kills
      ON npc._row_id=kills.npc_row_id
      WHERE kills.killer_name = "]]..PLAYER.name..[[" AND kills.date &gt;= ]]..von..[[ AND kills.date &lt;= ]]..bis..[[
      ORDER BY npc.place, npc.position ASC]]
  )
  self:_print_npc_list(npcs)
  iprint({"Es wurden ", {len(npcs), "y"}, " NPCs gefunden."}, "EK-Tracker")
end

------------------------------------------------------
--
------------------------------------------------------

function EK:delete(id)
  if self.del_flag and self.del_flag.id == id then
		db:delete(self.db.npc, self.del_flag.npc_query)
    db:delete(self.db.kills, self.del_flag.kill_entry_query)
		self.del_flag = nil
    iprint("Der EK wurde geloescht.", "EK-Tracker")
	else
		local npc_query = db:eq(self.db.npc.position, id)
    local npc = db:fetch(self.db.npc, npc_query)
    if len(npc) == 0 then
      iprint("Es wurde kein NPC mit der ID "..id.." gefunden.", "EK-Tracker")
      return
    elseif len(npc) &gt; 1 then
      iprint("Datenbank korrupt! Die ID "..id.." ist mehrfach vergeben.", "EK-Tracker")
      self:_print_npc(npc)
    else
      npc = npc[1]
    end
    iprint("Moechtest du folgenden EK aus der Liste loeschen? Falls ja, wiederhole den Befehl!", "EK-Tracker")
		self:_print_npc(npc)
    local kill_entry_query = db:eq(EK.db.kills.npc_row_id, npc["_row_id"])
    local all_kill_entries = db:fetch(EK.db.kills, kill_entry_query)
    if len(all_kill_entries) &gt; 0 then
      local names = {}
      for _,entry in pairs(all_kill_entries) do
        table.insert(names, entry.killer_name)
      end
      iprint("Beachte, dass der NPC als EK fuer "..table.concat(names, ", ").." gespeichert wurde.", "EK-Tracker")
    end
    self.del_flag = {id=id, npc_query=npc_query, kill_entry_query=kill_entry_query}
	end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:sort(old_id, new_id)
	local npcs = db:fetch(
    self.db.npc,
    db:OR(
      db:eq(self.db.npc.position, old_id),
      db:eq(self.db.npc.position, new_id)
    )
  )
  for _,npc in pairs(npcs) do
    if npc.position == old_id then
      npc.position = new_id
    else
      npc.position = old_id
    end
    db:update(self.db.npc, npc)
  end
  iprint("Die beiden Eintraege nach der Vertauschung: ", "EK-Tracker")
  self:_print_npc_list(npcs)
end

------------------------------------------------------
--
------------------------------------------------------

function EK:change(id, attr, content)
  local position = tonumber(id)
  if not position then
    eprint({"Die Eingabe", {id, "y"}, "ist keine Zahl."}, "EK-Tracker")
    return
  end

	if self.change_flag and self.change_flag.npc.position == position then
    self.change_flag.npc[self.attr[attr]] = self.change_flag.change
		db:update(self.db.npc, self.change_flag.npc)
    echo("\nDas Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;"..string.capitalize(attr))
    echo(" wurde zu \n")
    decho("&lt;0,255,0:0,0,0&gt;"..content)
    echo("\ngeaendert.\n\n")
		self:_print_npc(self.change_flag.npc)
    self.change_flag = nil
  else
    attr = string.lower(attr)
  	if not self.attr[attr] then
  		eprint({"Die Eingabe", {attr, "y"}, "ist kein gueltiges Attribut."}, "EK-Tracker")
      return
  	end
    if attr == "para" then
      local num = tonumber(content)
      if num and num &gt; -1 then
        content = num
      else
        eprint("Die Welt/Parallelwelt muss eine ganze Zahl groesser oder gleich 0 sein.", "EK-Tracker")
      end
    end
    local npc = db:fetch(
      self.db.npc,
      db:eq(self.db.npc.position, position)
    )
    if len(npc) == 0 then
      iprint({"Es konnte kein NPC mit der ID", {id, "y"}, "gefunden werden."}, "EK-Tracker")
      return
    elseif len(npc) &gt; 1 then
      eprint({"Datenbank ist korrupt! Mehrere NPCs mit der selben ID gefunden:"}, "EK-Tracker")
      self:_print_npc(npc)
      return
    end
    npc = npc[1]

    echo("Willst du bei ...\n\n")
		self:_print_npc(npc)
		echo("\n... wirklich das Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;"..string.capitalize(attr))
    echo(" zu \n")
    decho("&lt;0,255,0:0,0,0&gt;"..content)
    echo("\naendern? Falls ja, dann wiederhole den Befehl.\n\n")
		self.change_flag = {npc=npc, change=content}
	end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:multichange(ids, attr, content)
	display(ids, attr, content)

	if self.mchange_flag and self.mchange_flag.ids == ids then
    for _,npc in pairs(self.mchange_flag.npcs) do
      npc[self.attr[attr]] = self.mchange_flag.change
      db:update(self.db.npc, npc)
    end
    echo("\nDas Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;"..string.capitalize(attr))
    echo(" wurde zu \n")
    decho("&lt;0,255,0:0,0,0&gt;"..content)
    echo("\ngeaendert:\n")
    display("ok")
    self:_print_npc_list(self.mchange_flag.npcs, attr)
    self.mchange_flag = nil
    display("nice")
  else
    attr = string.lower(attr)
  	if not self.attr[attr] then
      display(attr)
  		eprint({"Die Eingabe", {attr, "y"}, "ist kein gueltiges Attribut."}, "EK-Tracker")
      return
  	end
    if attr == "para" then
      local num = tonumber(content)
      if num and num &gt; -1 then
        content = num
      else
        eprint("Die Welt/Parallelwelt muss eine ganze Zahl groesser oder gleich 0 sein.", "EK-Tracker")
      end
    end
    local npcs = db:fetch(
      self.db.npc,
      self:_get_id_query(ids)
    )
    if len(npcs) == 0 then
      iprint({"Es konnte kein NPCs mit den IDs", {ids, "y"}, "gefunden werden."}, "EK-Tracker")
      return
    end
    echo("Willst du bei ...\n\n")
		self:_print_npc_list(npcs, self.attr[attr])
		echo("\n... wirklich das Attribut ")
    decho("&lt;0,255,0:0,0,0&gt;"..string.capitalize(attr))
    echo(" zu \n")
    decho("&lt;0,255,0:0,0,0&gt;"..content)
    echo("\naendern? Falls ja, dann wiederhole den Befehl.\n\n")
		self.mchange_flag = {ids=ids, npcs = npcs, change=content}
  end
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Plaketten handling</name>
			<packageName></packageName>
			<script>------------------------------------------------------
--
------------------------------------------------------

function EK:save_plakettenabgleich(name, second_try)
  if self.player_hasnt &gt; -1 and self.competitor_hasnt &gt; -1 then
  	name = name:lower()
    --a = [[
    if PLAYER.name ~= "Mundron" and not second_try then
      tempTimer(3, function() EK:save_plakettenabgleich(name, true) end)
      return
    end
    local success, msg = db:add(
      self.db.competition,
      {
        player_name=PLAYER.name,
        player_count=self:count(),
        player_hasnt=self.player_hasnt,
        date=os.time(),
        competitor_name=name,
        competitor_count=self:count()-self.competitor_hasnt+self.player_hasnt,
        competitor_hasnt=self.competitor_hasnt
      }
    )
    if not success then
      if second_try then
        eprint("Fehler beim Speichern des Plakettenabgleichs: "..msg, "EK-Tracker")
        self.player_hasnt = -1
      	self.competitor_hasnt = -1
    	else
        wprint("Kurze Verzoegerung durch den Fehler: "..msg, "EK-Tracker")
        tempTimer(3, function() EK:save_plakettenabgleich(name, true) end)
      end
      return
    end
    --]]
  	self.player_hasnt = -1
  	self.competitor_hasnt = -1
  	self:show_friend(name)
    --b = [[
    self:show_friend(name)
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:del_abgleich(id)
	if self.pdel_flag.entry["_row_id"] == id then
		db:delete(EK.db.competition, self.pdel_flag.entry)
    self.pdel_flag = nil
	else
    -- have to use db:fetch_sql because db:fetch doesn't work with _row_id
    local entry = db:fetch_sql(self.db.competition,
      [[ SELECT competition.* FROM competition WHERE competition._row_id = ]]..id
    )
    if len(entry) == 0 then
      eprint({"Kein Plakettenvergleich mit der ID", {id, "y"}, "gefunden"}, "EK-Tracker")
      return
    end
    iprint({"Willst du wirklich den Eintrag mit der ID", {id, "y"}, "loeschen?"}, "EK-Tracker")
		self:show_friend(id)
		iprint("Falls ja, dann wiederhole den Befehl.", "EK-Tracker")
		self.pdel_flag = {entry=entry}
	end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:show_friend(name_or_id)
  local entries = {}
  local name = name_or_id
  if type(name_or_id) == "number" then
    entries = db:fetch_sql(self.db.competition,
      [[ SELECT competition.*
      FROM competition
      WHERE competition._row_id = ]]..id)
    if len(entries) &gt; 0 then
      name = entries[1]["competitor_name"]
    end
  else
    entries = db:fetch_sql(self.db.competition,
      [[ SELECT competition.*
       FROM competition
       WHERE competition.competitor_name = ']]..string.capitalize(name_or_id)..[['
       LIMIT 3]])
  end
  if len(entries) == 0 then
    iprint("Es wurden keine Eintraege gefunden.", "EK-Tracker")
    return
  end
  echo("\n\n")
	local tab = {}
	table.insert(tab, norm_length({"ID:", "", "", "",
																	"Deine EKs:",
																	"EKs von "..name..":",
																	"Dir fehlen:",
																	name.." fehlen:"}, 1))

  local previous_entry = {}
  local keys = {"player_count", "competitor_count", "player_hasnt", "competitor_hasnt"}
  for _,entry in pairs(entries) do
    local date = os.date("%d.%m.%y", entry["date"])
    local time = os.date("%H:%M", entry["date"])
    local values = {}
    local max_diff_len = 0
    for _,key in pairs(keys) do
      table.insert(values, EK:_num_plus_diff(entry[key], previous_entry[key]))
      max_diff_len = math.max(max_diff_len, #values[#values][3])
    end
    for i,v in pairs(values) do
      local spaces = " "
      for _=1,max_diff_len - #v[3],1 do
        spaces = spaces.." "
      end
      values[i] = v[1]..spaces..v[2]..v[3]
    end
  	table.insert(tab, norm_length({
      entry["_row_id"].." ",
  		date.." ",
  		time.." ", "",
  		unpack(values),
    }, 1, 2))
    previous_entry = entry
  end
	print_table(tab)
  echo("\n")
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>load_EK_database</name>
			<packageName></packageName>
			<script>------------------------------------------------------
--
------------------------------------------------------

function load_EK_database()
  EK:load_friends()
  if not EK.db then
    iprint("try to connect to npc database.", "EK-Tracker")
    EK.db, db_is_new = db:create("npc_list", {
      npc = {
        position=0,
        name="",
        place="",
        region="",
        creator="",
        hint="",
        world=0,
        killpoints="true",
        _index={"name", "position"},
        _violations = "IGNORE"
      },
      kills = {
        killer_name="",
        npc_row_id=0,
        date=0,
        _index={"name"},
        _violations = "IGNORE"
      },
      competition = {
        player_name="",
        competitor_name="",
        date=0,
        player_count=0,
        player_hasnt=0,
        competitor_count=0,
        competitor_hasnt=0,
        _index={"player_name", "competitor_name"}
      }
    }, true)
    iprint("connected to npc database.", "EK-Tracker")
    if db_is_new  then
      iprint("database was newly created", "EK-Tracker")
      if lfs.attributes(getMundronCoreDir().."EK_Liste.csv") then
        wprint("Process to transfer old file to database started!", "EK-Tracker")
        -- this function will be hopefully needed just once
        -- no need to declare it permanently
        function EK_transfer(transfer_npc_id, this_lines, names, unknowns)
          iprint("EK data transfer part 1/"..(1+#names).." npc transfer at "..transfer_npc_id.."/"..(transfer_npc_id+#this_lines-1), "EK-Tracker")
          npc = this_lines[1]
          table.remove(this_lines, 1)
          local npc_doc = {
            position=transfer_npc_id,
            name=npc[1],
            place=npc[2],
            region=npc[3],
            creator=npc[4],
            hint=npc[5],
            world=npc[6]
          }
          tempTimer(0.1, function() db:add(EK.db.npc, npc_doc) end)
          local kills = {}
          for i,player_name in ipairs(names) do
            date = npc[6+i]
            if #date &gt; 0 then
              if #date == 1 then
                date=0
              else
                local d, m, y = date:match("(%d+).(%d+).(%d+)")
                date = os.time({year=2000+y, month=m, day=d})
              end
              table.insert(kills, {
                killer_name=player_name,
                npc_row_id=transfer_npc_id,
                date=date
              })
            end
          end
          if #kills &gt; 0 then
            tempTimer(0.1, function() db:add(EK.db.kills, unpack(kills)) end)
          end
          if #this_lines &gt; 0 then
            tempTimer(0.1, function() EK_transfer(transfer_npc_id+1, this_lines, names, unknowns) end)
          else
            EK_add_unknown_kills(1,1,names, unknowns)
          end
        end -- end of EK_transfer
        function EK_add_unknown_kills(killer_id, unknown_id, names, unknowns)
          if unknowns[killer_id] &gt; 0 then
            iprint("EK data transfer part "..(1+killer_id).."/"..(1+#names).." add unknown kill of "..names[killer_id]..": "..unknown_id.."/"..unknowns[killer_id], "EK-Tracker")
            local doc = {
              killer_name=names[killer_id],
              npc_row_id=-unknown_id
            }
            tempTimer(0.1, function() db:add(EK.db.kills, doc) end)
          else
            iprint("EK data transfer part "..(1+killer_id).."/"..(1+#names).." no unknown kills to add for "..names[killer_id], "EK-Tracker")
          end

          if unknown_id &lt; unknowns[killer_id] then
            tempTimer(0.1, function() EK_add_unknown_kills(killer_id, unknown_id+1,names, unknowns) end)
          else
            if killer_id &lt; #names then
              tempTimer(0.1, function() EK_add_unknown_kills(killer_id+1, 1, names, unknowns) end)
            else
              iprint("Write 'lua EK_competition_transfer()' in your console after your login to transfer the competition data into the database.", "EK-Tracker")
            end
          end
        end -- end of EK_add_unknown_kills
        local EK_Liste = mload_csv("EK_Liste")
        local header = EK_Liste[1]
        table.remove(EK_Liste, 1)

        local names = {}
        local unknowns = {}
        for _,val in ipairs(header) do
          if tonumber(val) then
            table.insert(unknowns, tonumber(val))
          else
            table.insert(names, val)
          end
        end
        EK_transfer(1, EK_Liste, names, unknowns)
      else
        wprint("No file found. New database was created!", "EK-Tracker")
      end
    end
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK_competition_transfer()
  function EK_comp_trans_iter(index, friend, comps)
    local day, month, year, hour, min = comps[index][4]:match(
      "(%d+).(%d+).(%d+) (%d+):(%d+)"
    )
    iprint("Push friend "..friend.." to database "..index.."/"..#comps, "EK-Tracker")
    local player_count = tonumber(comps[index][1])
    local competitor_hasnt = tonumber(comps[index][2])
    local player_hasnt = tonumber(comps[index][3])
    tempTimer(0.1, function()
      db:add(EK.db.competition, {
        player_name=PLAYER.name,
        competitor_name=friend,
        date=os.time({year=2000+year, month=month, day=day, hour=hour, min=min}),
        player_count=player_count,
        player_hasnt=player_hasnt,
        competitor_count=player_count-competitor_hasnt+player_hasnt,
        competitor_hasnt=competitor_hasnt,
      }) end)
    if index &lt; #comps then
      tempTimer(0.1, function() EK_comp_trans_iter(index+1, friend, comps) end)
    end
  end
  function EK_all_comp_trans_iter()
    local cnt = 1
    for friend,comps in pairs(EK.friends) do
      tempTimer(cnt, function() EK_comp_trans_iter(1, friend, comps) end)
    end
  end
  EK_all_comp_trans_iter()
end

function EK:export(filename)
  local npcs = db:fetch(self.db.npc, nil, {self.db.npc.position})
  local npc_table = {{
    "_row_id",
    "position",
    "name",
    "place",
    "region",
    "creator",
    "world",
    "killpoints",
    "hint"
  }}
  local _row_id_to_position = {}
  for _,npc in pairs(npcs) do
    table.insert(npc_table, {
      tostring(npc["_row_id"]),
      tostring(npc["position"]),
      npc["name"],
      npc["place"],
      npc["region"],
      npc["creator"],
      tostring(npc["world"]),
      tostring(npc["killpoints"]),
      npc["hint"]
    })
    _row_id_to_position[npc._row_id] = npc.position
  end
  msave_csv(filename.."_NPC", npc_table)
  iprint("Export 1/3: NPCs exportiert.", "EK-Tracker")
  local kills = db:fetch(self.db.kills, nil,
    {self.db.kills.killer_name, self.db.kills.npc_row_id})
  local kills_table = {{"killer_name", "position", "date"}}
  for _,kill_entry in pairs(kills) do
    local date = "unbekannt"
    if kill_entry["date"] &gt; 0 then
      date = os.date("%d.%m.%y", kill_entry["date"])
    end
    table.insert(kills_table, {
      kill_entry["killer_name"],
      tostring(_row_id_to_position[kill_entry["npc_row_id"]] or kill_entry["npc_row_id"]),
      date
    })
  end
  msave_csv(filename.."_Kills", kills_table)
  iprint("Export 2/3: EK-Eintraege exportiert.", "EK-Tracker")
  local comps = db:fetch(self.db.competition, nil, {self.db.competition.player_name})
  local comp_table = {{
    "player_name",
    "competitor_name",
    "date",
    "player_count",
    "player_hasnt",
    "competitor_count",
    "competitor_hasnt"
  }}
  for _,comp_entry in pairs(comps) do
    date = os.date("%d.%m.%y ", comp_entry["date"])
    table.insert(comp_table, {
      comp_entry["player_name"],
      comp_entry["competitor_name"],
      date,
      comp_entry["player_count"],
      comp_entry["player_hasnt"],
      comp_entry["competitor_count"],
      comp_entry["competitor_hasnt"]
    })
  end
  msave_csv(filename.."_Competition", comp_table)
  iprint("Export 3/3: Plaketten-Vergleich exportiert.", "EK-Tracker")
  iprint("Export abgeschlossen", "EK-Tracker")
end

------------------------------------------------------
--
------------------------------------------------------

function EK:import(filename)
  local d, m, y = von:match("(%d+)\.(%d+)\.(%d+)")
  von = os.time{year=2000+y, month=m, day=d}
end
</script>
			<eventHandlerList>
				<string>sysConnectionEvent</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>helpers</name>
			<packageName></packageName>
			<script>------------------------------------------------------
--
------------------------------------------------------

function EK:_get_attr_query(conditions)
  local result = {}
  for _,prop_group in pairs(conditions) do
    local temp = {}
    for prop,value in pairs(prop_group) do
      if self.attr[prop] then
        prop = self.attr[prop]
      end
      if type(value) == "number" then
        table.insert(
          temp,
          db:eq(self.db.npc[prop], value)
        )
      else
        table.insert(
          temp,
          db:like(self.db.npc[prop], "%"..value:lower().."%")
        )
      end
    end
    if len(temp) == 1 then
      table.insert(result, temp[1])
    else
      table.insert(result, db:AND(unpack(temp)))
    end
  end
  if len(result) == 1 then
    return result[1]
  else
    local real_result = result[1]
    table.remove(result, 1)
    for _,query in pairs(result) do
      real_result = db:OR(real_result, query)
    end
    return real_result
  end
end

------------------------------------------------------
--
------------------------------------------------------

function EK:_get_id_query(id_string)
  local result = {}
  for von, bis in id_string:gmatch("(%d+) bis (%d+)") do
    table.insert(result, {von=tonumber(von), bis=tonumber(bis)})
  end
  id_string = id_string:gsub("(%d+) bis (%d+)", "")
  for id in id_string:gmatch("%d+") do
    table.insert(result, tonumber(id))
  end
  if len(result) == 0 then
    return nil
  end
  local queries = {}
  for _,num in pairs(result) do
    if type(num) == "number" then
      table.insert(queries, db:eq(self.db.npc.position, num))
    else
      table.insert(queries, db:AND(
        db:gte(self.db.npc.position, num.von),
        db:lte(self.db.npc.position, num.bis)
      ))
    end
  end
  if len(queries) == 1 then
    return queries[1]
  end
  local query_result = queries[1]
  table.remove(queries, 1)
  for _,q in pairs(queries) do
    query_result = db:OR(query_result, q)
  end
  return query_result
end

------------------------------------------------------
--
------------------------------------------------------

function EK:_kill_entry(npc)
  if not npc["_row_id"] then
    return nil
  end
  local npc_row_id = npc["_row_id"]
  return db:fetch(
    EK.db.kills,
    {
      db:eq(EK.db.kills.killer_name, PLAYER.name),
      db:eq(EK.db.kills.npc_row_id, npc_row_id)
    }
  )[1]
end

------------------------------------------------------
--
------------------------------------------------------

function EK:_print_npc(npc)
  if not npc then
    eprint("Unzulaessiger NPC zur Anzeige uebergeben.", "EK-Tracker")
    display(npc)
    return
  end
  if len(npc) == 0 then
    iprint("Kein NPC gefunden.", "EK-Tracker")
    return
  end
  if npc[1] then
    for _,single_npc in ipairs(npc) do
      self:_print_npc(single_npc)
    end
    if len(npc) &gt; 1 then
      iprint("Es wurden "..len(npc).." Einträge gefunden.", "EK-Tracker")
    end
    return
  end
  local ort = "Ort"
  local world = tonumber(npc["world"]) or 0
	ort = ort .."("..world.."):"
	if world&gt;0 then
	  ort = "&lt;255,255,0:0,0,0&gt;"..ort
  else
	  ort = "&lt;0,255,0:0,0,0&gt;"..ort
  end
  local npc_table = {
    {
      "&lt;0,255,0:0,0,0&gt;ID:",
      "&lt;0,255,0:0,0,0&gt;Name:",
      ort,
      "&lt;0,255,0:0,0,0&gt;Region:",
      "&lt;0,255,0:0,0,0&gt;Magier:",
    },
    {
      npc["position"] or "",
      npc["name"] or "",
      npc["place"] or "",
      npc["region"] or "",
      npc["creator"] or "",
    }
  }
  table.insert(npc_table[1], "&lt;0,255,0:0,0,0&gt;Hinweis:")
	local hintlines = break_lines(npc["hint"] or "")
  table.insert(npc_table[2], hintlines[1])
  for i=2,len(hintlines) do
    table.insert(npc_table[1], "")
    table.insert(npc_table[2], hintlines[i])
  end
  if npc["killpoints"] then
    table.insert(npc_table[1], "&lt;0,255,0:0,0,0&gt;Geholt:")
  	local kill_entry = self:_kill_entry(npc)
    if len(kill_entry) &gt; 0 then
      if kill_entry["date"] == 0 then
      	table.insert(npc_table[2], "unbekannt")
  	  else
    		table.insert(npc_table[2], os.date("%d.%m.%y", kill_entry["date"]))
  	  end
    else
  		table.insert(npc_table[2], "&lt;255,0,0:0,0,0&gt;Nein")
  	end
  else
    table.insert(npc_table[1], "&lt;255,255,0:0,0,0&gt;Kein EK")
    table.insert(npc_table[2], "")
  end
  echo("\n")
  print_table(norm_table(npc_table, -1, 1))
end

------------------------------------------------------
--
------------------------------------------------------

function EK:_print_npc_list(npcs, prop, no_killer)
  if len(npcs) == 0 then
    iprint("Keine NPCs gefunden.", "EK-Tracker")
    return
  end
  local npc_table = {{}, {}, {}, {}}
  prop = prop or "place"
  for i,npc in ipairs(npcs) do
    local index = npc["position"]
    if no_killer or not self:_kill_entry(npc) then
      index = "&lt;0,255,0:0,0,0&gt;"..index
    else
      index = "&lt;255,255,0:0,0,0&gt;"..index
    end
    local prop_title = self.attr_name[prop]
    if prop == "place" then
      prop_title = prop_title.."("..npc["world"].."):"
      if npc["world"] &gt; 0 then
        prop_title  = "&lt;255,200,0:0,0,0&gt;"..prop_title
      else
        prop_title  = "&lt;0,255,0:0,0,0&gt;"..prop_title
      end
    else
      prop_title = "&lt;0,255,0:0,0,0&gt;"..prop_title
    end
    table.insert(npc_table[1], index)
    table.insert(npc_table[2], npc["name"]:sub(1,30))
    table.insert(npc_table[3], prop_title)
    table.insert(npc_table[4], npc[prop]:sub(1,30))
  end
  echo("\n")
  print_table(norm_table(npc_table, -1, 1))
end

------------------------------------------------------
--
------------------------------------------------------

function EK:_num_plus_diff(base, reference)
	if type(reference) == "nil" then
    return {tostring(base), "", ""}
	end
  local difference = base - reference
	local sign = "+"
  local diff_color = "&lt;0,255,0:0,0,0&gt;"
	if difference&lt;0 then
		sign = "" -- don't change to "-", because the negative value has already the sign
    diff_color = "&lt;255,255,0:0,0,0&gt;"
	end
  return {tostring(base), diff_color, "("..sign..difference..")"}
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
